<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WireMock JSON Studio</title>
    <link rel="icon" type="image/x-icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/animations.css">
    <link rel="stylesheet" href="../styles/components.css">
    <link rel="stylesheet" href="../styles/modals.css">
    <link rel="stylesheet" href="../styles/main.css">
    <link href="json-editor.css" rel="stylesheet">
</head>
<body data-theme="dark">
    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display: none;" aria-hidden="true">
        <symbol id="icon-logo" viewBox="0 0 24 24">
            <path d="M12 2.5c-5.24 0-9.5 4.26-9.5 9.5s4.26 9.5 9.5 9.5c3.02 0 5.72-1.39 7.45-3.58a1 1 0 00-.78-1.62h-5.17a2.75 2.75 0 110-5.5h5.17a1 1 0 00.78-1.62C17.72 3.89 15.02 2.5 12 2.5z" fill="currentColor"/>
        </symbol>
        <symbol id="icon-moon" viewBox="0 0 24 24">
            <path d="M21 12.79A9 9 0 0111.21 3 7 7 0 0012 21a7 7 0 009-8.21z" fill="currentColor"/>
        </symbol>
        <symbol id="icon-sun" viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="4" fill="currentColor"/>
            <path d="M12 3v2M12 19v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M3 12h2M19 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
        </symbol>
        <symbol id="icon-clipboard" viewBox="0 0 24 24">
            <path d="M9 4h6a2 2 0 012 2v12a2 2 0 01-2 2H9a2 2 0 01-2-2V6a2 2 0 012-2z" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/>
            <path d="M9 2.75A1.75 1.75 0 0110.75 1h2.5A1.75 1.75 0 0115 2.75V4H9z" fill="currentColor"/>
        </symbol>
        <symbol id="icon-inbox" viewBox="0 0 24 24">
            <path d="M4.75 6.5A1.75 1.75 0 016.5 4.75h11a1.75 1.75 0 011.75 1.75v6a1.75 1.75 0 01-1.75 1.75h-2.94a2.06 2.06 0 00-1.46.6l-.7.7a2.06 2.06 0 01-1.46.6h-1.48a2.06 2.06 0 01-1.46-.6l-.7-.7a2.06 2.06 0 00-1.46-.6H6.5A1.75 1.75 0 014.75 12.5z" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/>
            <path d="M12 7v4m0 0l2-2m-2 2l-2-2" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
        </symbol>
        <symbol id="icon-masks" viewBox="0 0 24 24">
            <path d="M5 6a4 4 0 014-4h6a4 4 0 014 4v5a4 4 0 01-4 4h-2l-2 2-2-2H9a4 4 0 01-4-4z" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/>
            <path d="M9 9a1 1 0 11-2 0m8 0a1 1 0 11-2 0" fill="currentColor"/>
            <path d="M8.5 11.5c1.5 1 3.5 1 5 0" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
        </symbol>
        <symbol id="icon-box" viewBox="0 0 24 24">
            <path d="M3.5 7.5L12 3l8.5 4.5v9L12 21l-8.5-4.5z" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/>
            <path d="M12 21v-9" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
            <path d="M20.5 7.5l-8.5 4.5L3.5 7.5" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/>
        </symbol>
        <symbol id="icon-mic" viewBox="0 0 24 24">
            <rect x="9" y="4" width="6" height="10" rx="3" fill="none" stroke="currentColor" stroke-width="1.5"/>
            <path d="M5 10a7 7 0 0014 0" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
            <path d="M12 20v-3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
            <path d="M9 20h6" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
        </symbol>
        <symbol id="icon-settings" viewBox="0 0 24 24">
            <path d="M10.325 4.317a1.75 1.75 0 013.35 0l.287.955a1.75 1.75 0 001.651 1.224h1.003a1.75 1.75 0 011.237 2.987l-.725.725a1.75 1.75 0 000 2.475l.725.725a1.75 1.75 0 01-1.237 2.987h-1.003a1.75 1.75 0 00-1.651 1.224l-.287.955a1.75 1.75 0 01-3.35 0l-.287-.955a1.75 1.75 0 00-1.651-1.224H8.384a1.75 1.75 0 01-1.237-2.987l.725-.725a1.75 1.75 0 000-2.475l-.725-.725a1.75 1.75 0 011.237-2.987h1.003a1.75 1.75 0 001.651-1.224z" fill="none" stroke="currentColor" stroke-width="1.3"/>
            <circle cx="12" cy="12" r="3" fill="currentColor"/>
        </symbol>
        <symbol id="icon-refresh" viewBox="0 0 24 24">
            <path d="M4.5 12a7.5 7.5 0 0112.73-5.3L19.5 9" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
            <path d="M19.5 6v3a1 1 0 01-1 1h-3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
            <path d="M19.5 12a7.5 7.5 0 01-12.73 5.3L4.5 15" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
            <path d="M4.5 18v-3a1 1 0 011-1h3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
        </symbol>
        <symbol id="icon-bolt" viewBox="0 0 24 24">
            <path d="M11 2L5 13h5v9l6-11h-5z" fill="currentColor"/>
        </symbol>
        <symbol id="icon-plus" viewBox="0 0 24 24">
            <path d="M12 5v14m-7-7h14" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
        </symbol>
        <symbol id="icon-search" viewBox="0 0 24 24">
            <path d="M21 21l-4.35-4.35" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
            <circle cx="11" cy="11" r="6" stroke="currentColor" stroke-width="1.5" fill="none"/>
        </symbol>
        <symbol id="icon-trending-up" viewBox="0 0 24 24">
            <path d="M3 17l6-6 4 4 7-7" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
            <path d="M14 5h7v7" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
        </symbol>
        <symbol id="icon-database" viewBox="0 0 24 24">
            <ellipse cx="12" cy="5" rx="7" ry="3" stroke="currentColor" stroke-width="1.5" fill="none"/>
            <path d="M5 5v6c0 1.66 3.13 3 7 3s7-1.34 7-3V5" stroke="currentColor" stroke-width="1.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M5 11v6c0 1.66 3.13 3 7 3s7-1.34 7-3v-6" stroke="currentColor" stroke-width="1.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
        </symbol>
        <symbol id="icon-clock" viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="9" stroke="currentColor" stroke-width="1.5" fill="none"/>
            <path d="M12 7v5l3 2" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
        </symbol>
        <symbol id="icon-trash" viewBox="0 0 24 24">
            <path d="M5 7h14" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
            <path d="M9 7V5a2 2 0 012-2h2a2 2 0 012 2v2" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
            <path d="M6 7l1 12a2 2 0 002 2h6a2 2 0 002-2l1-12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M10 11v6m4-6v6" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
        </symbol>
        <symbol id="icon-pencil" viewBox="0 0 24 24">
            <path d="M4 17.5V20h2.5l11-11-2.5-2.5-11 11z" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/>
            <path d="M14.5 4.5l2.5 2.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
        </symbol>
        <symbol id="icon-open-external" viewBox="0 0 24 24">
            <path d="M13 5h6v6" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M11 13l8-8" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
            <path d="M19 13v5a2 2 0 01-2 2H7a2 2 0 01-2-2V7a2 2 0 012-2h5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
        </symbol>
        <symbol id="icon-check-circle" viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="9" stroke="currentColor" stroke-width="1.5" fill="none"/>
            <path d="M9.5 12.5l2 2 4-4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
        </symbol>
        <symbol id="icon-x-circle" viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="9" stroke="currentColor" stroke-width="1.5" fill="none"/>
            <path d="M9.5 9.5l5 5m0-5l-5 5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
        </symbol>
        <symbol id="icon-request-in" viewBox="0 0 24 24">
            <path d="M6 6a2 2 0 012-2h8a2 2 0 012 2v4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
            <path d="M7 12l5 5 5-5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M12 17V6" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
        </symbol>
        <symbol id="icon-response-out" viewBox="0 0 24 24">
            <path d="M18 18a2 2 0 01-2 2H8a2 2 0 01-2-2v-4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
            <path d="M12 7v11" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
            <path d="M7 11l5-5 5 5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
        </symbol>
        <symbol id="icon-info" viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="9" stroke="currentColor" stroke-width="1.5" fill="none"/>
            <path d="M12 8h.01M11 11h1v4h1" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
        </symbol>
        <symbol id="icon-broom" viewBox="0 0 24 24">
            <path d="M4 16l4 4 10-10-4-4z" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/>
            <path d="M16 6l3-3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
        </symbol>
        <symbol id="icon-save" viewBox="0 0 24 24">
            <path d="M5 5a2 2 0 012-2h9l3 3v13a2 2 0 01-2 2H7a2 2 0 01-2-2z" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/>
            <path d="M9 3v5h6V3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
            <rect x="9" y="13" width="6" height="5" rx="1" fill="currentColor"/>
        </symbol>
        <symbol id="icon-play" viewBox="0 0 24 24">
            <path d="M8 5v14l10-7z" fill="currentColor"/>
        </symbol>
        <symbol id="icon-stop" viewBox="0 0 24 24">
            <rect x="7" y="7" width="10" height="10" rx="1.5" fill="currentColor"/>
        </symbol>
        <symbol id="icon-code-brackets" viewBox="0 0 24 24">
            <path d="M9 7L5 12l4 5" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M15 7l4 5-4 5" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M13 5l-2 14" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
        </symbol>
        <symbol id="icon-arrows-in" viewBox="0 0 24 24">
            <path d="M9 8L5 12l4 4" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M15 8l4 4-4 4" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M14 12h-4" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
        </symbol>
        <symbol id="icon-minus" viewBox="0 0 24 24">
            <path d="M6 12h12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
        </symbol>
    </svg>
    <div class="editor-app">
        <section class="editor-toolbar card card-static json-editor-toolbar" aria-label="Editor controls">
            <div class="toolbar-row toolbar-row--primary">
                <div class="toolbar-side toolbar-side--left">
                    <div class="toolbar-brand" aria-label="WireMock JSON Studio">
                        <span class="logo-badge" aria-hidden="true">WM</span>
                        <span class="sr-only">WireMock JSON Studio</span>
                    </div>
                    <div class="search-container" role="toolbar" aria-label="Editor utilities">
                        <div class="search-actions" role="group" aria-label="Editor utilities">
                            <button class="btn btn-icon btn-secondary btn-icon-compact" onclick="openTextFindWidget()" title="Find (Ctrl+F)" data-tooltip="Open find (Ctrl+F)">
                                <svg class="icon icon-16" aria-hidden="true" focusable="false">
                                    <use href="#icon-search"></use>
                                </svg>
                                <span class="sr-only">Open find widget</span>
                            </button>
                            <button class="btn btn-icon btn-secondary btn-icon-compact" onclick="openJSONPathWidget()" title="JSONPath (Alt+J)" data-tooltip="Open JSONPath mode (Alt+J)">
                                <svg class="icon icon-16" aria-hidden="true" focusable="false">
                                    <use href="#icon-code-brackets"></use>
                                </svg>
                                <span class="sr-only">Open JSONPath find widget</span>
                            </button>
                            <span class="search-actions__divider" role="presentation" aria-hidden="true"></span>
                            <button class="btn btn-icon btn-secondary btn-icon-compact" onclick="formatJSON()" title="Format JSON" data-tooltip="Pretty print JSON">
                                <svg class="icon icon-16" aria-hidden="true" focusable="false">
                                    <use href="#icon-broom"></use>
                                </svg>
                                <span class="sr-only">Format JSON</span>
                            </button>
                            <button class="btn btn-icon btn-secondary btn-icon-compact" onclick="minifyJSON()" title="Minify JSON" data-tooltip="Minify JSON">
                                <svg class="icon icon-16" aria-hidden="true" focusable="false">
                                    <use href="#icon-arrows-in"></use>
                                </svg>
                                <span class="sr-only">Minify JSON</span>
                            </button>
                            <button class="btn btn-icon btn-secondary btn-icon-compact" onclick="sortJSONKeys()" title="Sort keys (Ctrl+Alt+S)" data-tooltip="Sort keys alphabetically (Ctrl+Alt+S)">
                                <svg class="icon icon-16" aria-hidden="true" focusable="false">
                                    <use href="#icon-trending-up"></use>
                                </svg>
                                <span class="sr-only">Sort JSON keys</span>
                            </button>
                            <button class="btn btn-icon btn-secondary btn-icon-compact" onclick="collapseAllJSON()" title="Collapse all (Ctrl+Shift+[)" data-tooltip="Collapse all blocks (Ctrl+Shift+[)">
                                <svg class="icon icon-16" aria-hidden="true" focusable="false">
                                    <use href="#icon-minus"></use>
                                </svg>
                                <span class="sr-only">Collapse all JSON blocks</span>
                            </button>
                            <button class="btn btn-icon btn-secondary btn-icon-compact" onclick="expandAllJSON()" title="Expand all (Ctrl+Shift+])" data-tooltip="Expand all blocks (Ctrl+Shift+])">
                                <svg class="icon icon-16" aria-hidden="true" focusable="false">
                                    <use href="#icon-plus"></use>
                                </svg>
                                <span class="sr-only">Expand all JSON blocks</span>
                            </button>
                            <button class="btn btn-icon btn-secondary btn-icon-compact" onclick="validateJSON()" title="Validate JSON" data-tooltip="Validate JSON">
                                <svg class="icon icon-16" aria-hidden="true" focusable="false">
                                    <use href="#icon-check-circle"></use>
                                </svg>
                                <span class="sr-only">Validate JSON</span>
                            </button>
                            <span class="search-actions__divider" role="presentation" aria-hidden="true"></span>
                            <button class="btn btn-icon btn-secondary btn-icon-compact" onclick="openModal()" title="WireMock Templates" data-tooltip="WireMock templates">
                                <svg class="icon icon-16" aria-hidden="true" focusable="false">
                                    <use href="#icon-box"></use>
                                </svg>
                                <span class="sr-only">WireMock templates</span>
                            </button>
                            <button class="btn btn-icon btn-secondary btn-icon-compact" onclick="openHistoryModal()" title="History" data-tooltip="Show history">
                                <svg class="icon icon-16" aria-hidden="true" focusable="false">
                                    <use href="#icon-clock"></use>
                                </svg>
                                <span class="sr-only">History</span>
                            </button>
                            <span class="search-actions__divider" role="presentation" aria-hidden="true"></span>
                            <button class="btn btn-icon btn-secondary btn-icon-compact" onclick="exportAsYAML()" title="Export as YAML" data-tooltip="Export YAML">
                                <svg class="icon icon-16" aria-hidden="true" focusable="false">
                                    <use href="#icon-open-external"></use>
                                </svg>
                                <span class="sr-only">Export as YAML</span>
                            </button>
                        </div>
                    </div>
                </div>
                <div class="toolbar-side toolbar-side--right">
                    <div class="btn-group" id="editorControls" role="group" aria-label="Workspace actions">
                        <button class="btn btn-primary" onclick="updateMappingOnServer()" title="Update mapping" data-tooltip="Update existing mapping in WireMock">
                            <svg class="icon icon-16" aria-hidden="true" focusable="false">
                                <use href="#icon-refresh"></use>
                            </svg>
                            <span class="btn-label">Update</span>
                        </button>
                        <button class="btn btn-secondary" onclick="createMappingOnServer()" title="Create mapping" data-tooltip="Create new mapping in WireMock">
                            <svg class="icon icon-16" aria-hidden="true" focusable="false">
                                <use href="#icon-plus"></use>
                            </svg>
                            <span class="btn-label">Create</span>
                        </button>
                        <button class="btn btn-secondary" onclick="newDocument()" title="Blank (Ctrl+N)" data-tooltip="New document (Ctrl+N)">
                            <svg class="icon icon-16" aria-hidden="true" focusable="false">
                                <use href="#icon-clipboard"></use>
                            </svg>
                            <span class="btn-label">Blank</span>
                        </button>
                        <button class="btn btn-secondary" onclick="loadFile()" title="Upload (Ctrl+O)" data-tooltip="Upload JSON from file (Ctrl+O)">
                            <svg class="icon icon-16" aria-hidden="true" focusable="false">
                                <use href="#icon-inbox"></use>
                            </svg>
                            <span class="btn-label">Upload</span>
                        </button>
                        <button class="btn btn-secondary" onclick="downloadCurrentMapping()" title="Download (Ctrl+S)" data-tooltip="Download JSON (Ctrl+S)">
                            <svg class="icon icon-16" aria-hidden="true" focusable="false">
                                <use href="#icon-save"></use>
                            </svg>
                            <span class="btn-label">Download</span>
                        </button>
                    </div>
                    <button class="btn btn-icon btn-secondary btn-icon-compact toolbar-theme-toggle" onclick="toggleEditorTheme()" title="Toggle theme" data-tooltip="Toggle theme">
                        <svg class="icon icon-16" aria-hidden="true" focusable="false">
                            <use id="editor-theme-icon" href="#icon-moon"></use>
                        </svg>
                        <span class="sr-only">Toggle theme</span>
                    </button>
                </div>
            </div>
        </section>
        <main class="editor-main">
            <div class="drag-overlay" id="dragOverlay">
                <div class="drag-text">
                    Drop JSON files here
                </div>
            </div>
            <div class="editor-container" id="editorContainer">
                <div id="jsonEditor" class="editor-surface"></div>
            </div>
            <div class="compare-container" id="compareContainer" style="display: none;">
                <div class="compare-panel">
                    <div id="compareEditorLeft" class="editor-surface"></div>
                </div>
                <div class="compare-panel">
                    <div id="compareEditorRight" class="editor-surface"></div>
                </div>
            </div>
        </main>
    </div>

    <!-- Templates Modal -->
    <div class="modal hidden" id="fullscreenModal" role="dialog" aria-modal="true" aria-labelledby="modal-title-templates" aria-hidden="true">
        <div class="modal-content">
            <button class="modal-close" type="button" onclick="closeModal()" aria-label="Close templates modal">
                <svg class="icon icon-16" aria-hidden="true" focusable="false">
                    <use href="#icon-x-circle"></use>
                </svg>
                <span class="sr-only">Close</span>
            </button>
            <div class="modal-header">
                <h2 id="modal-title-templates">WireMock Templates</h2>
            </div>
            <div class="modal-body">
                <div class="template-grid" id="templateGrid">
                <!-- Templates will be loaded here -->
            </div>
            </div>
        </div>
    </div>

    <div class="modal hidden" id="templatePreviewModal" role="dialog" aria-modal="true" aria-labelledby="modal-title-template-preview" aria-hidden="true">
        <div class="modal-content modal-content--wide">
            <button class="modal-close" type="button" onclick="closeModal('templatePreviewModal')" aria-label="Close template preview">
                <svg class="icon icon-16" aria-hidden="true" focusable="false">
                    <use href="#icon-x-circle"></use>
                </svg>
                <span class="sr-only">Close</span>
            </button>
            <div class="modal-header">
                <h2 id="modal-title-template-preview">Template preview</h2>
            </div>
            <div class="modal-body template-preview-body">
                <p class="template-preview-description" id="templatePreviewDescription"></p>
                <div class="template-preview-meta" id="templatePreviewMeta"></div>
                <pre class="template-preview-code" id="templatePreviewCode"></pre>
                <div class="template-preview-actions" id="templatePreviewActions">
                    <button class="btn btn-primary btn-sm" type="button" data-template-action="apply">Use template</button>
                    <button class="btn btn-secondary btn-sm" type="button" data-template-action="copy">Copy JSON</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal hidden modal--stacked" id="historyPreviewModal" role="dialog" aria-modal="true" aria-labelledby="modal-title-history-preview" aria-hidden="true">
        <div class="modal-content modal-content--wide">
            <button class="modal-close" type="button" onclick="closeModal('historyPreviewModal')" aria-label="Close history preview">
                <svg class="icon icon-16" aria-hidden="true" focusable="false">
                    <use href="#icon-x-circle"></use>
                </svg>
                <span class="sr-only">Close</span>
            </button>
            <div class="modal-header">
                <h2 id="modal-title-history-preview">Snapshot preview</h2>
            </div>
            <div class="modal-body history-preview-body">
                <div class="history-preview-meta" id="historyPreviewMeta"></div>
                <pre class="history-preview-summary" id="historyPreviewSummary"></pre>
                <pre class="history-preview-code" id="historyPreviewContent"></pre>
                <div class="history-preview-actions" id="historyPreviewActions">
                    <button class="btn btn-primary btn-sm" type="button" data-history-preview-action="restore">Restore</button>
                    <button class="btn btn-secondary btn-sm" type="button" data-history-preview-action="copy">Copy JSON</button>
                </div>
            </div>
        </div>
    </div>

    <!-- History Modal -->
    <div class="modal hidden" id="historyModal" role="dialog" aria-modal="true" aria-labelledby="modal-title-history" aria-hidden="true">
        <div class="modal-content">
            <button class="modal-close" type="button" onclick="closeHistoryModal()" aria-label="Close history modal">
                <svg class="icon icon-16" aria-hidden="true" focusable="false">
                    <use href="#icon-x-circle"></use>
                </svg>
                <span class="sr-only">Close</span>
            </button>
            <div class="modal-header">
                <h2 id="modal-title-history">History</h2>
            </div>
            <div class="modal-body">
                <div class="history-list" id="historyList">
                <!-- History items will be loaded here -->
            </div>
            </div>
        </div>
    </div>
    
    <div id="loadingOverlay" class="loading-overlay" aria-hidden="true">
        <div class="loading-spinner" role="status" aria-live="polite"></div>
    </div>
    
    <!-- Performance Optimization Scripts -->
    <script src="performance-optimizations.js"></script>
    
    <!-- Monaco Editor Loader (must be loaded first) -->
    <script>
        window.MONACO_CDN_SOURCES = [
            { label: 'jsDelivr', baseUrl: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.44.0/min/vs' },
            { label: 'cdnjs', baseUrl: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs' },
            { label: 'unpkg', baseUrl: 'https://unpkg.com/monaco-editor@0.44.0/min/vs' }
        ];

        const primaryMonacoSource = window.MONACO_CDN_SOURCES[0];
        const primaryMonacoBase = primaryMonacoSource && primaryMonacoSource.baseUrl
            ? primaryMonacoSource.baseUrl
            : 'https://cdn.jsdelivr.net/npm/monaco-editor@0.44.0/min/vs';

        window.require = window.require || {};
        window.require.paths = Object.assign({}, window.require.paths || {}, {
            vs: primaryMonacoBase.replace(/\/+$/, '')
        });
    </script>
    <script id="monaco-loader-script" src="https://cdn.jsdelivr.net/npm/monaco-editor@0.44.0/min/vs/loader.js"></script>
    <script>
        (function setupMonacoLoaderFallback() {
            const loaderScript = document.getElementById('monaco-loader-script');
            if (!loaderScript) {
                return;
            }

            const sources = Array.isArray(window.MONACO_CDN_SOURCES)
                ? window.MONACO_CDN_SOURCES.slice(1)
                : [];

            if (!sources.length) {
                return;
            }

            let attemptIndex = 0;

            const tryNext = () => {
                if (attemptIndex >= sources.length) {
                    console.error('Failed to load Monaco loader from all configured sources');
                    return;
                }

                const source = sources[attemptIndex++];
                if (!source || !source.baseUrl) {
                    tryNext();
                    return;
                }

                const baseUrl = source.baseUrl.replace(/\/+$/, '');
                window.require = window.require || {};
                window.require.paths = Object.assign({}, window.require.paths || {}, { vs: baseUrl });

                const fallbackScript = document.createElement('script');
                fallbackScript.src = `${baseUrl}/loader.js`;
                fallbackScript.async = false;
                fallbackScript.dataset.monacoLoader = source.label || baseUrl;
                fallbackScript.onerror = tryNext;

                document.head.appendChild(fallbackScript);
            };

            loaderScript.onerror = () => {
                loaderScript.onerror = null;
                tryNext();
            };
        })();
    </script>
    
    <!-- WireMock URL initialization - moved to initializeFromURL -->

    <!-- WireMock Integration -->
    <script src="../js/vendor-js-yaml.min.js"></script>
    <script src="../js/core.js"></script>
    <script src="../js/managers.js"></script>
    <script src="../js/demo-data.js"></script>
    <script src="../js/features/state.js"></script>
    <script src="../js/features/utils.js"></script>
    <script src="../js/features/filters.js"></script>
    <script src="../js/features/cache.js"></script>
    <script src="../js/features/mappings.js"></script>
    <script src="../js/features/requests.js"></script>
    <script src="../js/features/scenarios.js"></script>
    <script src="../js/features/recording.js"></script>
    <script src="../js/features/management.js"></script>
    <script src="../js/features/request-api.js"></script>
    <script src="../js/features/near-misses.js"></script>
    <script src="../js/features/wiremock-extras.js"></script>
    <script src="../js/features/demo.js"></script>
    <script src="../js/features.js"></script>
    <script src="../js/main.js"></script>

    <!-- Monaco Enhanced (our main editor) -->
    <script src="monaco-template-library.js"></script>
    <script src="monaco-enhanced.js"></script>

    <script>
        const editorUrlParams = new URLSearchParams(window.location.search);
        const initialMappingId = (editorUrlParams.get('mappingId') || '').trim() || null;

        const editorMappingContext = {
            initialMappingId,
            lastKnownId: initialMappingId,
            getFallbackId() {
                return this.lastKnownId || this.initialMappingId || null;
            },
            remember(id) {
                if (!id) return;
                const trimmed = String(id).trim();
                if (!trimmed) return;
                this.lastKnownId = trimmed;
            }
        };

        window.editorMappingContext = editorMappingContext;
        window.rememberEditorMappingId = (id) => editorMappingContext.remember(id);

        function resolveMappingIdentifier(mapping) {
            if (!mapping || typeof mapping !== 'object') {
                return null;
            }

            const id = mapping.id || mapping.uuid;
            return id && String(id).trim() ? String(id).trim() : null;
        }

        /**
         * Show notification
         */
        function showNotification(message, type = 'info') {
            const manager = window.NotificationManager;
            const normalizedType = (type || 'info').toString().toLowerCase();

            if (manager && typeof manager.show === 'function') {
                try {
                    if (typeof manager[normalizedType] === 'function') {
                        manager[normalizedType](message);
                    } else {
                        manager.show(message, normalizedType);
                    }
                    return;
                } catch (error) {
                    console.warn('NotificationManager failed, falling back to console log:', error);
                }
            }

            const label = normalizedType.toUpperCase();
            console.log(`[${label}] ${message}`);
        }

        /**
         * Toggle the editor loading overlay
         */
        function setEditorLoadingState(isLoading, label) {
            const overlay = document.getElementById('loadingOverlay');
            if (!overlay) {
                return;
            }

            const spinner = overlay.querySelector('.loading-spinner');
            if (isLoading) {
                overlay.classList.add('show');
                overlay.setAttribute('aria-hidden', 'false');
                overlay.setAttribute('aria-busy', 'true');
                if (spinner) {
                    if (label) {
                        spinner.setAttribute('aria-label', label);
                    } else {
                        spinner.removeAttribute('aria-label');
                    }
                }
            } else {
                overlay.classList.remove('show');
                overlay.setAttribute('aria-hidden', 'true');
                overlay.removeAttribute('aria-busy');
                if (spinner) {
                    spinner.removeAttribute('aria-label');
                }
            }
        }

        /**
         * Save to history (editor-specific implementation)
         */
        function saveToHistory(content, action) {
            try {
                if (!window.monacoInitializer || typeof window.monacoInitializer.recordHistorySnapshot !== 'function') {
                    console.log(`[HISTORY] ${action || 'snapshot'}: history service unavailable`);
                    return;
                }

                const serialized = typeof content === 'string'
                    ? content
                    : JSON.stringify(content, null, 2);

                window.monacoInitializer.recordHistorySnapshot(action || 'Manual snapshot', {
                    label: action || 'Manual snapshot',
                    manual: true,
                    force: true,
                    contentOverride: serialized
                });
                window.monacoInitializer.refreshHistoryUI({ force: true });
            } catch (error) {
                console.warn('History save failed:', error);
            }
        }

        /**
         * Apply optimistic mapping update to local cache if available
         */
        function applyOptimisticMappingUpdateLocally(mappingData) {
            try {
                console.log('ðŸŽ¯ [OPTIMISTIC] Applying optimistic update locally:', mappingData.id);

                // Try to update local cache if available
                if (typeof window.applyOptimisticMappingUpdate === 'function') {
                    console.log('ðŸŽ¯ [OPTIMISTIC] Using local applyOptimisticMappingUpdate');

                    // In editor context, we only update cache without rendering
                    try {
                        if (!mappingData) return;
                        const m = mappingData.mapping || mappingData;
                        if (!m || !m.id) return;
                        // MEMORY OPTIMIZATION: allMappings/originalMappings are getters, can't be assigned

                        // drop service cache mapping if ever present
                        if (typeof isImockCacheMapping === 'function' && isImockCacheMapping(m)) return; // never render the service mapping

                        // MEMORY OPTIMIZATION: Update cacheManager.cache directly
                        if (window.cacheManager && window.cacheManager.cache instanceof Map) {
                            window.cacheManager.cache.set(m.id, m);
                        }

                        console.log('ðŸŽ¯ [OPTIMISTIC] Cache updated successfully in editor context');
                        console.log('ðŸŽ¯ [OPTIMISTIC] Updated mapping:', m.name || m.id);
                        console.log('ðŸŽ¯ [OPTIMISTIC] allMappings size:', window.allMappings.length);
                        return true;
                    } catch (e) {
                        console.warn('ðŸŽ¯ [OPTIMISTIC] Local cache update failed:', e);
                        return false;
                    }
                }

                // Fallback: try to update via postMessage to parent
                if (window.parent && window.parent !== window) {
                    try {
                        console.log('ðŸŽ¯ [OPTIMISTIC] Sending optimistic update via postMessage to parent');
                        console.log('ðŸŽ¯ [OPTIMISTIC] Mapping data:', { id: mappingData.id, name: mappingData.name });
                        window.parent.postMessage({
                            type: 'imock-optimistic-mapping-update',
                            mapping: mappingData,
                            source: 'json-editor',
                            timestamp: Date.now()
                        }, '*');
                        console.log('ðŸŽ¯ [OPTIMISTIC] PostMessage sent successfully');
                        return true;
                    } catch (e) {
                        console.warn('ðŸŽ¯ [OPTIMISTIC] Parent postMessage failed:', e);
                    }
                }

                // Fallback: try BroadcastChannel
                if (typeof BroadcastChannel !== 'undefined') {
                    try {
                        console.log('ðŸŽ¯ [OPTIMISTIC] Sending optimistic update via BroadcastChannel');
                        console.log('ðŸŽ¯ [OPTIMISTIC] BroadcastChannel mapping data:', { id: mappingData.id, name: mappingData.name });
                        const channel = new BroadcastChannel('imock-optimistic-updates');
                        channel.postMessage({
                            type: 'optimistic-mapping-update',
                            mapping: mappingData,
                            source: 'json-editor',
                            timestamp: Date.now()
                        });
                        channel.close();
                        console.log('ðŸŽ¯ [OPTIMISTIC] BroadcastChannel message sent successfully');
                        return true;
                    } catch (e) {
                        console.warn('ðŸŽ¯ [OPTIMISTIC] BroadcastChannel failed:', e);
                    }
                }

                console.log('âš ï¸ No method available for optimistic update');
                return false;
            } catch (error) {
                console.warn('Error applying optimistic update locally:', error);
                return false;
            }
        }

        /**
         * Try to refresh cache in parent window or broadcast to all windows
         */
        function tryRefreshParentCache() {
            try {
                console.log('ðŸ”„ Attempting to refresh cache in parent/all windows...');

                // Method 1: Direct call to parent window (popup scenario)
                if (window.opener && typeof window.opener.refreshImockCache === 'function') {
                    console.log('ðŸ”„ Refreshing cache via direct parent call...');
                    window.opener.refreshImockCache().catch(error => {
                        console.warn('Failed to refresh cache in parent window:', error);
                    });
                    return;
                }

                // Method 2: Try parent window via postMessage
                if (window.parent && window.parent !== window) {
                    try {
                        console.log('ðŸ”„ Refreshing cache via parent postMessage...');
                        window.parent.postMessage({
                            type: 'imock-cache-refresh',
                            source: 'json-editor',
                            timestamp: Date.now()
                        }, '*');
                    } catch (e) {
                        console.warn('Parent postMessage failed:', e);
                    }
                }

                // Method 3: Broadcast to all windows via localStorage (cross-tab communication)
                try {
                    console.log('ðŸ”„ Refreshing cache via localStorage broadcast...');
                    localStorage.setItem('imock-cache-refresh-trigger', Date.now().toString());
                    // Clean up immediately to avoid spam
                    setTimeout(() => {
                        localStorage.removeItem('imock-cache-refresh-trigger');
                    }, 100);
                } catch (e) {
                    console.warn('localStorage broadcast failed:', e);
                }

                // Method 4: Try BroadcastChannel API (modern browsers)
                if (typeof BroadcastChannel !== 'undefined') {
                    try {
                        console.log('ðŸ”„ Refreshing cache via BroadcastChannel...');
                        const channel = new BroadcastChannel('imock-cache-refresh');
                        channel.postMessage({
                            type: 'cache-refresh',
                            source: 'json-editor',
                            timestamp: Date.now()
                        });
                        channel.close();
                    } catch (e) {
                        console.warn('BroadcastChannel failed:', e);
                    }
                }

                // Method 5: Try to find main window by iterating through window frames
                try {
                    if (window.top && window.top !== window) {
                        const frames = window.top.frames;
                        for (let i = 0; i < frames.length; i++) {
                            try {
                                const frame = frames[i];
                                if (frame && typeof frame.refreshImockCache === 'function') {
                                    console.log('ðŸ”„ Refreshing cache via frame iteration...');
                                    frame.refreshImockCache().catch(e => console.warn('Frame refresh failed:', e));
                                }
                            } catch (e) {
                                // Ignore cross-origin errors
                            }
                        }
                    }
                } catch (e) {
                    console.warn('Frame iteration failed:', e);
                }

                console.log('ðŸ”„ Cache refresh attempts completed');
            } catch (error) {
                console.warn('Error trying to refresh parent cache:', error);
            }
        }

        /**
         * Download file (editor-specific implementation)
         */
        function downloadFile(content, filename, mimeType) {
            try {
                const blob = new Blob([content], { type: mimeType || 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showNotification(`File downloaded: ${filename}`, 'success');
            } catch (error) {
                console.error('Download failed:', error);
                showNotification('Download failed: ' + error.message, 'error');
            }
        }

        /**
         * Modal helpers
         */
        const MODAL_FOCUSABLE_SELECTORS = [
            'button:not([disabled])',
            'a[href]',
            'input:not([disabled])',
            'select:not([disabled])',
            'textarea:not([disabled])',
            '[tabindex]:not([tabindex="-1"])'
        ].join(', ');

        function tryFocusElement(element) {
            if (!element || typeof element.focus !== 'function') {
                return;
            }

            try {
                element.focus({ preventScroll: true });
            } catch (e) {
                element.focus();
            }
        }

        function setModalVisibility(modal, shouldShow) {
            if (!(modal instanceof HTMLElement)) {
                return;
            }

            if (shouldShow) {
                modal.classList.remove('hidden');
                modal.classList.add('show');
                modal.style.display = 'flex';
                modal.setAttribute('aria-hidden', 'false');

                if (!modal.__triggerElement && document.activeElement instanceof HTMLElement) {
                    modal.__triggerElement = document.activeElement;
                }

                document.body.classList.add('modal-open');

                const focusTarget = modal.querySelector('[data-autofocus]') || modal.querySelector(MODAL_FOCUSABLE_SELECTORS);
                if (focusTarget) {
                    tryFocusElement(focusTarget);
                } else {
                    modal.setAttribute('tabindex', '-1');
                    tryFocusElement(modal);
                }
            } else {
                const trigger = modal.__triggerElement instanceof HTMLElement ? modal.__triggerElement : null;
                const activeElement = document.activeElement instanceof HTMLElement ? document.activeElement : null;
                const hadFocusInside = activeElement ? modal.contains(activeElement) : false;

                if (hadFocusInside) {
                    if (trigger) {
                        tryFocusElement(trigger);
                    } else if (activeElement && typeof activeElement.blur === 'function') {
                        activeElement.blur();
                    }
                }

                modal.classList.remove('show');
                modal.classList.add('hidden');
                modal.style.display = 'none';
                modal.setAttribute('aria-hidden', 'true');

                delete modal.__triggerElement;

                if (!document.querySelector('.modal.show, .modal[aria-hidden="false"]')) {
                    document.body.classList.remove('modal-open');
                }

                if (!hadFocusInside && trigger) {
                    tryFocusElement(trigger);
                }
            }
        }

        function openModal(modalId = 'fullscreenModal') {
            const modal = document.getElementById(modalId);
            if (!modal) {
                console.warn(`Modal with id "${modalId}" not found`);
                return;
            }

            if (modalId === 'fullscreenModal' && typeof window.renderTemplateLibrary === 'function') {
                window.renderTemplateLibrary();
            }

            if (modalId === 'historyModal' && typeof window.renderHistoryModal === 'function') {
                window.renderHistoryModal();
            }

            setModalVisibility(modal, true);
        }

        function closeModal(modalId = 'fullscreenModal') {
            const modal = document.getElementById(modalId);
            if (!modal) {
                console.warn(`Modal with id "${modalId}" not found`);
                return;
            }

            setModalVisibility(modal, false);
        }

        function openHistoryModal() {
            openModal('historyModal');
        }

        function closeHistoryModal() {
            closeModal('historyModal');
        }

        /**
         * Toggle theme
         */
        const globalToggleTheme = typeof window !== 'undefined' ? window.toggleTheme : null;
        function toggleEditorTheme() {
            if (typeof globalToggleTheme === 'function') {
                globalToggleTheme();
                return;
            }

            const body = document.body;
            const currentTheme = body.getAttribute('data-theme') || 'dark';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            body.setAttribute('data-theme', newTheme);

            const icon = document.getElementById('editor-theme-icon');
            if (icon) {
                const target = newTheme === 'dark' ? '#icon-sun' : '#icon-moon';
                icon.setAttribute('href', target);
                icon.setAttribute('xlink:href', target);
            }

            localStorage.setItem('theme', newTheme);
            if (typeof showNotification === 'function') {
                showNotification(`Switched to ${newTheme} theme`, 'success');
            }
        }

        function newDocument() {
            try {
                if (window.monacoInitializer && typeof window.monacoInitializer.newDocument === 'function') {
                    window.monacoInitializer.newDocument();
                    const editor = window.monacoInitializer.getActiveEditor ? window.monacoInitializer.getActiveEditor() : null;
                    if (editor && typeof editor.getValue === 'function' && typeof saveToHistory === 'function') {
                        saveToHistory(editor.getValue(), 'New document');
                    }
                } else {
                    showNotification('New document action not available', 'error');
                }
            } catch (error) {
                console.error('New document error:', error);
                showNotification('Error creating new document: ' + error.message, 'error');
            }
        }

        function clearComparePanel(side) {
            const target = side || 'both';
            try {
                if (window.monacoInitializer && typeof window.monacoInitializer.clearCompareContent === 'function') {
                    window.monacoInitializer.clearCompareContent(target);
                } else {
                    showNotification('Clear panel action not available', 'error');
                }
            } catch (error) {
                console.error('Clear panel error:', error);
                showNotification('Error clearing panel: ' + error.message, 'error');
            }
        }

        function exportAsYAML() {
            try {
                if (window.monacoInitializer && typeof window.monacoInitializer.exportAsYAML === 'function') {
                    window.monacoInitializer.exportAsYAML();
                } else {
                    showNotification('Export to YAML is not available', 'error');
                }
            } catch (error) {
                console.error('Export YAML error:', error);
                showNotification('Export YAML error: ' + error.message, 'error');
            }
        }

        /**
         * Switch mode between editor and compare
         */
        function switchMode(mode) {
            const editorContainer = document.getElementById('editorContainer');
            const compareContainer = document.getElementById('compareContainer');
            const editorControls = document.getElementById('editorControls');
            const compareControls = document.getElementById('compareControls');
            const modeTabs = document.querySelectorAll('.mode-tab');
            
            modeTabs.forEach(tab => {
                tab.classList.remove('active');
                if (tab.dataset.mode === mode) {
                    tab.classList.add('active');
                }
            });
            
            if (mode === 'compare') {
                editorContainer.style.display = 'none';
                compareContainer.style.display = 'flex';
                editorControls.style.display = 'none';
                compareControls.style.display = 'flex';
            } else {
                editorContainer.style.display = 'block';
                compareContainer.style.display = 'none';
                editorControls.style.display = 'flex';
                compareControls.style.display = 'none';
            }
            
            showNotification(`Switched to ${mode} mode`, 'success');
        }

        /**
         * Trigger Monaco find widget
         */
        function triggerFindWidget(mode = 'text') {
            try {
                if (window.monacoInitializer && typeof window.monacoInitializer.openFindWidget === 'function') {
                    const options = {
                        focus: true,
                        select: true
                    };

                    if (mode === 'jsonpath') {
                        options.jsonPathMode = true;
                    } else if (mode === 'text') {
                        options.jsonPathMode = false;
                    }

                    const result = window.monacoInitializer.openFindWidget(options);
                    if (result && typeof result.then === 'function') {
                        result.catch(error => {
                            console.error('Find widget error:', error);
                            showNotification('Find widget error: ' + error.message, 'error');
                        });
                    }
                } else {
                    showNotification('Find widget is not available', 'error');
                }
            } catch (error) {
                console.error('Find widget error:', error);
                showNotification('Find widget error: ' + error.message, 'error');
            }
        }

        /**
         * Open regular find widget
         */
        function openTextFindWidget() {
            triggerFindWidget('text');
        }

        /**
         * Open find widget in JSONPath mode
         */
        function openJSONPathWidget() {
            triggerFindWidget('jsonpath');
        }

        // Backwards compatibility for legacy handlers
        function searchJSONPath() {
            openJSONPathWidget();
        }

        /**
         * Format JSON
         */
        function formatJSON() {
            try {
                        if (window.monacoInitializer && typeof window.monacoInitializer.formatJSON === 'function') {
                            const currentContent = window.editor ? window.editor.getValue() : '';
                            window.monacoInitializer.formatJSON();
                            setTimeout(() => {
                                if (window.editor) {
                                    const newContent = window.editor.getValue();
                                    if (newContent !== currentContent) {
                                        saveToHistory(newContent, 'JSON Formatted');
                                        showNotification('JSON formatted', 'success');
                                    }
                                }
                            }, 100);
                } else {
                    showNotification('Format function not available', 'error');
                }
            } catch (error) {
                console.error('Format error:', error);
                showNotification('Format error: ' + error.message, 'error');
            }
        }

        /**
         * Minify JSON
         */
        function minifyJSON() {
            try {
                        if (window.monacoInitializer && typeof window.monacoInitializer.minifyJSON === 'function') {
                            const currentContent = window.editor ? window.editor.getValue() : '';
                            window.monacoInitializer.minifyJSON();
                            setTimeout(() => {
                                if (window.editor) {
                                    const newContent = window.editor.getValue();
                                    if (newContent !== currentContent) {
                                        saveToHistory(newContent, 'JSON Minified');
                                        showNotification('JSON minified', 'success');
                                    }
                                }
                            }, 100);
                } else {
                    showNotification('Minify function not available', 'error');
                }
            } catch (error) {
                console.error('Minify error:', error);
                showNotification('Minify error: ' + error.message, 'error');
            }
        }

        function sortJSONKeys() {
            try {
                if (window.monacoInitializer && typeof window.monacoInitializer.sortJSONKeys === 'function') {
                    const editor = window.monacoInitializer.getActiveEditor ? window.monacoInitializer.getActiveEditor() : null;
                    const currentContent = editor && typeof editor.getValue === 'function' ? editor.getValue() : '';
                    window.monacoInitializer.sortJSONKeys();
                    setTimeout(() => {
                        if (editor && typeof editor.getValue === 'function') {
                            const newContent = editor.getValue();
                            if (newContent !== currentContent) {
                                saveToHistory(newContent, 'JSON Keys Sorted');
                                showNotification('JSON keys sorted', 'success');
                            }
                        }
                    }, 100);
                } else {
                    showNotification('Sort keys function not available', 'error');
                }
            } catch (error) {
                console.error('Sort keys error:', error);
                showNotification('Sort keys error: ' + error.message, 'error');
            }
        }

        function collapseAllJSON() {
            try {
                if (window.monacoInitializer && typeof window.monacoInitializer.collapseAllFolds === 'function') {
                    window.monacoInitializer.collapseAllFolds({ focus: true });
                } else {
                    showNotification('Collapse all is not available', 'error');
                }
            } catch (error) {
                console.error('Collapse JSON error:', error);
                showNotification('Collapse JSON error: ' + error.message, 'error');
            }
        }

        function expandAllJSON() {
            try {
                if (window.monacoInitializer && typeof window.monacoInitializer.expandAllFolds === 'function') {
                    window.monacoInitializer.expandAllFolds({ focus: true });
                } else {
                    showNotification('Expand all is not available', 'error');
                }
            } catch (error) {
                console.error('Expand JSON error:', error);
                showNotification('Expand JSON error: ' + error.message, 'error');
            }
        }

        /**
         * Validate JSON
         */
        function validateJSON() {
            try {
                if (window.monacoInitializer && typeof window.monacoInitializer.validateJSON === 'function') {
                    window.monacoInitializer.validateJSON();
                } else {
                    showNotification('Validate function not available', 'error');
                }
            } catch (error) {
                console.error('Validate error:', error);
                showNotification('Validate error: ' + error.message, 'error');
            }
        }

        /**
         * Load compare file
         */
        function loadCompareFile(side) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const content = e.target.result;
                            if (window.monacoInitializer && typeof window.monacoInitializer.loadCompareContent === 'function') {
                                window.monacoInitializer.loadCompareContent(side, content);
                            } else {
                                showNotification('Compare function not available', 'error');
                            }
                        } catch (error) {
                            showNotification('Error loading file: ' + error.message, 'error');
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        /**
         * Download current editor content
         */
        function downloadCurrentMapping() {
            try {
                if (window.monacoInitializer && typeof window.monacoInitializer.saveFile === 'function') {
                    window.monacoInitializer.saveFile();
                    return;
                }

                const editor = window.monacoInitializer && typeof window.monacoInitializer.getActiveEditor === 'function'
                    ? window.monacoInitializer.getActiveEditor()
                    : null;
                const content = editor && typeof editor.getValue === 'function' ? editor.getValue() : '';

                if (!content) {
                    showNotification('No content available for download', 'warning');
                    return;
                }

                downloadFile(content, 'wiremock-mapping.json', 'application/json');
                showNotification('File downloaded', 'success');
            } catch (error) {
                console.error('Download error:', error);
                showNotification('Download error: ' + error.message, 'error');
            }
        }

        function getMappingFromEditorSnapshot() {
            if (!window.monacoInitializer || typeof window.monacoInitializer.getMappingFromEditor !== 'function') {
                showNotification('Editor not ready for mapping operations', 'error');
                return null;
            }

            const mapping = window.monacoInitializer.getMappingFromEditor();
            if (!mapping) {
                showNotification('No valid JSON to process', 'warning');
                return null;
            }

            return mapping;
        }

        function normalizeMappingIdentifiers(mapping) {
            if (!mapping || typeof mapping !== 'object') {
                return;
            }

            if (typeof mapping.id === 'string') {
                const trimmed = mapping.id.trim();
                if (trimmed) {
                    mapping.id = trimmed;
                } else {
                    delete mapping.id;
                }
            }

            if (typeof mapping.uuid === 'string') {
                const trimmed = mapping.uuid.trim();
                if (trimmed) {
                    mapping.uuid = trimmed;
                } else {
                    delete mapping.uuid;
                }
            }
        }

        function ensureMappingMetadata(mapping, { isCreate } = {}) {
            if (!mapping || typeof mapping !== 'object') {
                return;
            }

            const nowIso = new Date().toISOString();
            if (!mapping.metadata || typeof mapping.metadata !== 'object') {
                mapping.metadata = {};
            }

            if (isCreate && !mapping.metadata.created) {
                mapping.metadata.created = nowIso;
            } else if (!mapping.metadata.created) {
                mapping.metadata.created = nowIso;
            }

            mapping.metadata.edited = nowIso;
            mapping.metadata.source = 'editor';
        }

        function propagateMappingUpdate(mappingData) {
            if (!mappingData) {
                return;
            }

            applyOptimisticMappingUpdateLocally(mappingData);

            if (window.opener && typeof window.opener.applyOptimisticMappingUpdate === 'function') {
                try {
                    window.opener.applyOptimisticMappingUpdate(mappingData);
                } catch (error) {
                    console.warn('Failed to push optimistic update to opener:', error);
                }
            } else if (window.opener) {
                try {
                    window.opener.postMessage({
                        type: 'imock-optimistic-mapping-update',
                        mapping: mappingData,
                        source: 'json-editor-save',
                        timestamp: Date.now()
                    }, '*');
                } catch (error) {
                    console.warn('Failed to postMessage optimistic update to opener:', error);
                }
            }
        }

        function buildDownloadFilename(mapping, suffix = 'wiremock-mapping') {
            const base = mapping && mapping.name ? String(mapping.name) : suffix;
            const normalized = base.toLowerCase().replace(/[^a-z0-9-_]+/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
            return (normalized || suffix) + '.json';
        }

        async function executeWireMockOperation(mapping, { mode, targetId }) {
            const editor = window.monacoInitializer && typeof window.monacoInitializer.getActiveEditor === 'function'
                ? window.monacoInitializer.getActiveEditor()
                : null;

            if (editor) {
                editor.updateOptions({ readOnly: true });
            }

            const serialized = JSON.stringify(mapping, null, 2);

            try {
                if (!window.apiFetch || !window.wiremockBaseUrl) {
                    throw new Error('WireMock is not connected');
                }

                const endpoint = mode === 'update' ? `/mappings/${encodeURIComponent(targetId)}` : '/mappings';
                const method = mode === 'update' ? 'PUT' : 'POST';
                const response = await window.apiFetch(endpoint, {
                    method,
                    headers: { 'Content-Type': 'application/json' },
                    body: serialized
                });

                const payload = response?.mapping || response;
                const successMessage = mode === 'update'
                    ? `Mapping ${targetId || payload?.id} updated successfully`
                    : `Mapping ${payload?.id || mapping.name || 'new mapping'} created successfully`;

                showNotification(successMessage, 'success');
                propagateMappingUpdate(payload || mapping);

                const rememberedId = resolveMappingIdentifier(payload) || resolveMappingIdentifier(mapping);
                if (rememberedId) {
                    editorMappingContext.remember(rememberedId);
                }

                return payload;
            } catch (error) {
                console.error('WireMock operation failed:', error);
                const filename = buildDownloadFilename(mapping, mode === 'update' ? 'wiremock-update' : 'wiremock-create');
                downloadFile(serialized, filename, 'application/json');
                saveToHistory(serialized, mode === 'update' ? 'Saved as download (update fallback)' : 'Saved as download (create fallback)');
                showNotification('WireMock unavailable, mapping downloaded instead', 'warning');
                return null;
            } finally {
                if (editor) {
                    editor.updateOptions({ readOnly: false });
                }
            }
        }

        async function updateMappingOnServer() {
            const mapping = getMappingFromEditorSnapshot();
            if (!mapping) {
                return;
            }

            normalizeMappingIdentifiers(mapping);

            let targetId = resolveMappingIdentifier(mapping);
            if (targetId) {
                const confirmed = window.confirm(`Update mapping ${targetId}? Current data on the server will be replaced.`);
                if (!confirmed) {
                    showNotification('Update cancelled', 'info');
                    return;
                }
            } else {
                const fallbackId = editorMappingContext.getFallbackId();
                if (!fallbackId) {
                    showNotification('Cannot update mapping: no identifier available', 'error');
                    return;
                }

                const confirmed = window.confirm(`The JSON does not contain an id. Use cached id ${fallbackId} for update?`);
                if (!confirmed) {
                    showNotification('Update cancelled', 'info');
                    return;
                }

                mapping.id = fallbackId;
                if (!mapping.uuid) {
                    mapping.uuid = fallbackId;
                }
                targetId = fallbackId;
            }

            if (mapping.uuid && !mapping.id) {
                mapping.id = mapping.uuid;
            }

            ensureMappingMetadata(mapping, { isCreate: false });
            editorMappingContext.remember(targetId);

            await executeWireMockOperation(mapping, { mode: 'update', targetId });
        }

        async function createMappingOnServer() {
            const mapping = getMappingFromEditorSnapshot();
            if (!mapping) {
                return;
            }

            normalizeMappingIdentifiers(mapping);

            const label = mapping.name || mapping.request?.url || mapping.request?.urlPath || 'new mapping';
            const confirmed = window.confirm(`Create a new mapping "${label}" in WireMock?`);
            if (!confirmed) {
                showNotification('Creation cancelled', 'info');
                return;
            }

            ensureMappingMetadata(mapping, { isCreate: true });

            const result = await executeWireMockOperation(mapping, { mode: 'create' });
            const rememberedId = resolveMappingIdentifier(result) || resolveMappingIdentifier(mapping);
            if (rememberedId) {
                editorMappingContext.remember(rememberedId);
            }
        }

        /**
         * Load file or mapping
         */
        function loadFile() {
            try {
                // Try WireMock integration first
                if (typeof WireMockManager !== 'undefined' && WireMockManager.isConnected()) {
                    const choice = confirm('Load from WireMock server or from local file?\nOK = WireMock Server\nCancel = Local File');
                    
                    if (choice) {
                        // Load from WireMock
                        WireMockManager.getAllMappings()
                            .then(mappings => {
                                if (mappings && mappings.length > 0) {
                                    // Show mapping selection modal or load first mapping
                                    const firstMapping = mappings[0];
                                    if (window.monacoInitializer && typeof window.monacoInitializer.loadMappingIntoEditor === 'function') {
                                        window.monacoInitializer.loadMappingIntoEditor(firstMapping);
                                        showNotification(`Loaded mapping: ${firstMapping.name || 'Unnamed'}`, 'success');
                                    }
                                } else {
                                    showNotification('No mappings found in WireMock', 'warning');
                                }
                            })
                            .catch(error => {
                                console.error('WireMock load failed:', error);
                                showNotification('Failed to load from WireMock: ' + error.message, 'error');
                            });
                        return;
                    }
                }
                
                // Load from local file
                if (window.monacoInitializer && typeof window.monacoInitializer.loadFile === 'function') {
                    window.monacoInitializer.loadFile();
                } else {
                    showNotification('Load function not available', 'error');
                }
            } catch (error) {
                console.error('Load error:', error);
                showNotification('Load error: ' + error.message, 'error');
            }
        }


        // Close modals when clicking outside
        document.addEventListener('click', (e) => {
            const target = e.target;
            if (target instanceof HTMLElement && target.classList.contains('modal') && target.getAttribute('aria-hidden') === 'false') {
                setModalVisibility(target, false);
            }
        });

        // Close modals with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const openModal = document.querySelector('.modal.show, .modal[aria-hidden="false"]');
                if (openModal instanceof HTMLElement) {
                    e.preventDefault();
                    setModalVisibility(openModal, false);
                }
            }
        });

        /**
         * Toggle performance monitoring display
         */
        function togglePerformanceMonitoring() {
            if (window.monacoInitializer && typeof window.monacoInitializer.showPerformanceBadge === 'function') {
                window.monacoInitializer.showPerformanceBadge();
                showNotification('Performance monitoring enabled', 'info');
            } else {
                showNotification('Performance monitoring not available', 'warning');
            }
        }

        /**
         * Get health statistics
         */
        function getHealthStats() {
            if (window.monacoInitializer && typeof window.monacoInitializer.getHealthStats === 'function') {
                const stats = window.monacoInitializer.getHealthStats();
                console.log('Health Stats:', stats);
                showNotification('Health stats logged to console', 'info');
                return stats;
            } else {
                showNotification('Health monitoring not available', 'warning');
                return null;
            }
        }

        /**
         * Test optimistic update functionality
         */
        function testOptimisticUpdate() {
            console.log('ðŸ§ª [TEST] Testing optimistic update functionality');

            // Get current mapping ID from URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            const currentMappingId = urlParams.get('mappingId');

            if (!currentMappingId) {
                console.warn('ðŸ§ª [TEST] No mapping ID found in URL, cannot test update');
                showNotification('Cannot test optimistic update - no mapping ID in URL', 'warning');
                return;
            }

            // Get current mapping data from editor
            let currentMapping;
            try {
                if (window.monacoInitializer && typeof window.monacoInitializer.getMappingFromEditor === 'function') {
                    currentMapping = window.monacoInitializer.getMappingFromEditor();
                }
            } catch (e) {
                console.warn('ðŸ§ª [TEST] Could not get mapping from editor:', e);
            }

            if (!currentMapping) {
                console.warn('ðŸ§ª [TEST] Could not retrieve current mapping data');
                showNotification('Cannot test optimistic update - failed to get current mapping', 'warning');
                return;
            }

            // Create a modified version of the current mapping for testing
            const testMapping = {
                ...currentMapping,
                id: currentMappingId,
                name: currentMapping.name + ' [OPTIMISTIC UPDATE ' + new Date().toLocaleTimeString() + ']',
                response: {
                    ...currentMapping.response,
                    jsonBody: {
                        ...currentMapping.response?.jsonBody,
                        _testUpdate: true,
                        _timestamp: new Date().toISOString()
                    }
                },
                metadata: {
                    ...currentMapping.metadata,
                    edited: new Date().toISOString(), // Update edited timestamp for test
                    source: 'editor-test'
                }
            };

            console.log('ðŸ§ª [TEST] Test mapping update created:', testMapping);

            // Test local optimistic update (updates editor's local arrays)
            const localResult = applyOptimisticMappingUpdateLocally(testMapping);
            console.log('ðŸ§ª [TEST] Local optimistic update result:', localResult);

            // Test direct call to main window's applyOptimisticMappingUpdate (if available)
            if (window.opener && typeof window.opener.applyOptimisticMappingUpdate === 'function') {
                try {
                    console.log('ðŸŽ¯ [TEST] Calling applyOptimisticMappingUpdate directly on opener...');
                    window.opener.applyOptimisticMappingUpdate(testMapping);
                    console.log('ðŸŽ¯ [TEST] Direct call to opener completed');
                } catch (e) {
                    console.warn('ðŸŽ¯ [TEST] Direct call to opener failed:', e);
                }
            } else {
                console.log('ðŸŽ¯ [TEST] Opener not available or function not found, trying postMessage...');
                // Fallback: try postMessage to parent/opener
                if (window.opener) {
                    try {
                        window.opener.postMessage({
                            type: 'imock-optimistic-mapping-update',
                            mapping: testMapping,
                            source: 'json-editor-test',
                            timestamp: Date.now()
                        }, '*');
                        console.log('ðŸŽ¯ [TEST] postMessage to opener sent');
                    } catch (e) {
                        console.warn('ðŸŽ¯ [TEST] postMessage to opener failed:', e);
                    }
                }
            }

            showNotification('Optimistic update test completed - check console logs and main window', 'info');
        }

        /**
         * Test cache refresh functionality
         */
        function testCacheRefresh() {
            console.log('ðŸ§ª [TEST] Testing cache refresh functionality');

            // Test cache refresh
            tryRefreshParentCache();
            console.log('ðŸ§ª [TEST] Cache refresh triggered');

            showNotification('Cache refresh test completed - check console logs and main window', 'info');
        }

        console.log('âœ… WireMock JSON Studio loaded with modal implementations');
        
        /**
         * Initialize URL parameters and load mapping if specified
         */
        function initializeFromURL() {
            if (window.initializedFromURL) {
                console.log('ðŸš€ initializeFromURL already called, skipping');
                return;
            }

            console.log('ðŸš€ initializeFromURL called');
            console.log('ðŸš€ Current URL:', window.location.href);
            console.log('ðŸš€ URL search params:', window.location.search);

            // WireMock URL initialization - single entry point
            const urlParams = new URLSearchParams(window.location.search);
            const settingsParam = urlParams.get('settings');

            let paramSettings = {};
            if (settingsParam) {
                try {
                    paramSettings = JSON.parse(decodeURIComponent(settingsParam));
                } catch (error) {
                    console.warn('âš ï¸ Failed to parse settings from URL parameter:', error);
                    paramSettings = {};
                }
            }

            let storedSettings = {};
            if (typeof window.readWiremockSettings === 'function') {
                storedSettings = window.readWiremockSettings();
            } else {
                try {
                    storedSettings = JSON.parse(localStorage.getItem('wiremock-settings') || '{}');
                } catch (error) {
                    console.warn('âš ï¸ Failed to parse stored settings from localStorage:', error);
                    storedSettings = {};
                }
            }

            const mergedSettings = {
                ...(storedSettings && typeof storedSettings === 'object' ? storedSettings : {}),
                ...(paramSettings && typeof paramSettings === 'object' ? paramSettings : {})
            };

            const normalizedSettings = (typeof window.normalizeWiremockSettings === 'function')
                ? window.normalizeWiremockSettings(mergedSettings)
                : mergedSettings;

            if (typeof window.ensureCustomHeaderObject === 'function') {
                window.customHeaders = window.ensureCustomHeaderObject(normalizedSettings.customHeaders || {});
            } else if (normalizedSettings.customHeaders && typeof normalizedSettings.customHeaders === 'object' && !Array.isArray(normalizedSettings.customHeaders)) {
                window.customHeaders = { ...normalizedSettings.customHeaders };
            } else {
                window.customHeaders = {};
            }

            const host = normalizedSettings.host || 'localhost';
            const port = normalizedSettings.port || '8080';

            window.wiremockBaseUrl = window.normalizeWiremockBaseUrl
                ? window.normalizeWiremockBaseUrl(host, port)
                : `http://${host}:${port}/__admin`;

            console.log('âœ… WireMock URL initialized in initializeFromURL:', window.wiremockBaseUrl);

            const mappingId = urlParams.get('mappingId');
            const mode = urlParams.get('mode');

            console.log('ðŸš€ Parsed parameters:', {
                mappingId,
                mode,
                settingsSource: settingsParam ? 'url' : 'storage',
                customHeaderCount: Object.keys(window.customHeaders || {}).length
            });

            if (mappingId) {
                console.log(`ðŸ” Loading mapping with ID: ${mappingId}`);
                loadMappingById(mappingId);
            } else {
                console.log('âš ï¸ No mappingId found in URL parameters');
            }

            if (mode) {
                console.log(`ðŸ”§ Setting mode to: ${mode}`);
                // Set mode if specified
                if (mode === 'compare') {
                    switchMode('compare');
                }
            }

            window.initializedFromURL = true;
        }
        
        /**
         * Load mapping by ID from WireMock
         */
        async function loadMappingById(mappingId) {
            try {
                console.log('ðŸ” loadMappingById called with mappingId:', mappingId);
                console.log('ðŸ” Current window.wiremockBaseUrl:', window.wiremockBaseUrl);
                console.log('ðŸ” window.getMappingById available:', typeof window.getMappingById);

                setEditorLoadingState(true, mappingId ? `Loading mapping ${mappingId}` : 'Loading mapping');

                // Clear any existing content while the mapping loads without polluting history
                if (window.monacoInitializer && typeof window.monacoInitializer.prepareEditorForMappingLoad === 'function') {
                    window.monacoInitializer.prepareEditorForMappingLoad(mappingId);
                } else if (window.monacoInitializer && window.monacoInitializer.isInitialized) {
                    const editor = window.monacoInitializer.getActiveEditor();
                    if (editor) {
                        const previousFlag = window.monacoInitializer.suspendHistoryRecording;
                        window.monacoInitializer.suspendHistoryRecording = true;
                        try {
                            editor.setValue('');
                        } finally {
                            window.monacoInitializer.suspendHistoryRecording = previousFlag;
                        }
                        if (window.monacoInitializer.historyDebounce) {
                            clearTimeout(window.monacoInitializer.historyDebounce);
                            window.monacoInitializer.historyDebounce = null;
                        }
                    }
                }

                // Wait for getMappingById function to be available
                let attempts = 0;
                while ((typeof window.getMappingById !== 'function') && attempts < 50) {
                    console.log(`â³ Waiting for getMappingById... attempt ${attempts + 1}`);
                    await new Promise(resolve => setTimeout(resolve, 100));
                    attempts++;
                }

                if (typeof window.getMappingById !== 'function') {
                    throw new Error('getMappingById function not available after 5 seconds');
                }

                console.log(`ðŸ“¡ Fetching mapping ${mappingId} from WireMock...`);
                console.log('ðŸ“¡ Using WireMock URL:', window.wiremockBaseUrl);

                const mapping = await window.getMappingById(mappingId);
                console.log('ðŸ“¡ API response received:', mapping);
                
                if (mapping) {
                    // Wait for Monaco editor to be ready
                    let editorAttempts = 0;
                    while ((!window.monacoInitializer || !window.monacoInitializer.isInitialized) && editorAttempts < 100) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        editorAttempts++;
                    }
                    
                    if (window.monacoInitializer && typeof window.monacoInitializer.loadMappingIntoEditor === 'function') {
                        window.monacoInitializer.loadMappingIntoEditor(mapping);
                        showNotification(`Mapping "${mapping.name || mappingId}" loaded successfully`, 'success');

                        // Update page title
                        document.title = `JSON Editor - ${mapping.name || mappingId}`;
                    } else {
                        throw new Error('Monaco editor not ready');
                    }
                } else {
                    throw new Error(`Mapping with ID ${mappingId} not found`);
                }
            } catch (error) {
                console.error('âŒ Error loading mapping:', error);
                console.error('âŒ Error details:', {
                    message: error.message,
                    stack: error.stack,
                    mappingId: mappingId,
                    wiremockUrl: window.wiremockBaseUrl
                });
                showNotification(`Failed to load mapping: ${error.message}`, 'error');

                if (window.monacoInitializer && typeof window.monacoInitializer.finalizeEditorMappingLoad === 'function') {
                    window.monacoInitializer.finalizeEditorMappingLoad();
                }

                // Show error in editor as comment
                const storedSettings = (typeof window.readWiremockSettings === 'function') ? window.readWiremockSettings() : {};
                const customHeadersForError = (storedSettings.customHeaders && Object.keys(storedSettings.customHeaders).length > 0)
                    ? JSON.stringify(storedSettings.customHeaders)
                    : '"NOT_SET"';

                const errorContent = `{
  "_error": "Failed to load mapping with ID: ${mappingId}",
  "_message": "${error.message.replace(/"/g, '\\"')}",
  "_wiremock_url": "${window.wiremockBaseUrl || 'NOT_SET'}",
  "_custom_headers": ${customHeadersForError},
  "_timestamp": "${new Date().toISOString()}",
  "_debug_info": "Check browser console (F12) for detailed logs",
  "_possible_issues": [
    "Mapping ID not found on server",
    "Authentication failed",
    "CORS policy blocking request",
    "Network connectivity issues",
    "WireMock server not responding"
  ]
}`;
                console.log('ðŸ“ Setting error content in editor:', errorContent);

                if (window.monacoInitializer && window.monacoInitializer.isInitialized) {
                    const editor = window.monacoInitializer.getActiveEditor();
                    if (editor) {
                        editor.setValue(errorContent);
                    }
                } else {
                    console.error('âŒ Monaco editor not ready to show error');
                    // Try to set content after a delay
                    setTimeout(() => {
                        if (window.monacoInitializer && window.monacoInitializer.getActiveEditor) {
                            const editor = window.monacoInitializer.getActiveEditor();
                            if (editor) {
                                editor.setValue(errorContent);
                            }
                        }
                    }, 1000);
                }
            } finally {
                setEditorLoadingState(false);
            }
        }
        
        // Initialize URL parameters - simplified and reliable approach
        console.log('ðŸš€ [DEBUG] Script block executing...');
        console.log('ðŸš€ Setting up URL initialization...');

        let initializationAttempts = 0;
        let initializationTimer = null;
        let initializationComplete = false;

        function dependenciesReady() {
            const hasMappingLookup = typeof window.getMappingById === 'function';
            const hasMonaco = Boolean(window.monacoInitializer && typeof window.monacoInitializer.getActiveEditor === 'function');

            console.log('ðŸš€ Checking readiness', { hasMappingLookup, hasMonaco });
            return hasMappingLookup && hasMonaco;
        }

        function clearInitializationTimer() {
            if (initializationTimer !== null) {
                clearInterval(initializationTimer);
                initializationTimer = null;
            }
        }

        function onFeaturesReady() {
            handleInitializationSuccess('features:state-ready');
        }

        function onMonacoReady() {
            handleInitializationSuccess('monaco:ready');
        }

        function handleInitializationSuccess(source) {
            if (initializationComplete) {
                return true;
            }

            if (!dependenciesReady()) {
                return false;
            }

            initializationComplete = true;
            clearInitializationTimer();
            window.removeEventListener('features:state-ready', onFeaturesReady);
            window.removeEventListener('monaco:ready', onMonacoReady);
            console.log(`âœ… Core components ready via ${source}. Initializing editor context.`);
            initializeFromURL();
            return true;
        }

        function handleInitializationFailure() {
            if (initializationComplete) {
                return;
            }

            console.error('âŒ Failed to initialize URL parameters after 30 seconds');
            if (window.monacoInitializer && typeof window.monacoInitializer.getActiveEditor === 'function') {
                const editor = window.monacoInitializer.getActiveEditor();
                if (editor) {
                    const payload = {
                        _error: 'Failed to initialize editor',
                        _message: 'Components failed to load properly',
                        _getMappingById: typeof window.getMappingById,
                        _monacoInitializer: !!window.monacoInitializer,
                        _wiremockBaseUrl: window.wiremockBaseUrl || 'NOT_SET'
                    };
                    try {
                        editor.setValue(JSON.stringify(payload, null, 2));
                    } catch (error) {
                        console.warn('Unable to write initialization failure to editor:', error);
                    }
                }
            }
        }

        function scheduleInitializationPoll() {
            if (initializationTimer !== null) {
                return;
            }

            initializationTimer = setInterval(() => {
                initializationAttempts += 1;
                console.log(`ðŸš€ Initialization attempt ${initializationAttempts}`);

                if (handleInitializationSuccess(`poll-${initializationAttempts}`)) {
                    return;
                }

                if (initializationAttempts >= 300) { // 30 seconds
                    clearInitializationTimer();
                    handleInitializationFailure();
                }
            }, 100);
        }

        if (!handleInitializationSuccess('immediate')) {
            scheduleInitializationPoll();
            window.addEventListener('features:state-ready', onFeaturesReady);
            window.addEventListener('monaco:ready', onMonacoReady);
        }
    </script>
</body>
</html>
