<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WireMock JSON Studio</title>
    <link rel="icon" type="image/x-icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/animations.css">
    <link rel="stylesheet" href="../styles/components.css">
    <link rel="stylesheet" href="../styles/modals.css">
    <link rel="stylesheet" href="../styles/main.css">
    <link href="json-editor.css" rel="stylesheet">
</head>
<body data-theme="light">
    <div class="editor-app">
        <section class="editor-toolbar card" aria-label="Editor controls">
            <div class="toolbar-row toolbar-row--primary">
                <div class="toolbar-side toolbar-side--left">
                    <div class="toolbar-brand">
                        <span class="logo-badge" aria-hidden="true">WM</span>
                        <div class="toolbar-text">
                        </div>
                    </div>
                    <div class="search-container" role="toolbar" aria-label="Editor utilities">
                        <div class="search-actions" role="group" aria-label="Editor utilities">
                            <button class="btn btn-icon btn-secondary btn-icon-compact" onclick="openTextFindWidget()" title="Find (Ctrl+F)" data-tooltip="Open find (Ctrl+F)">
                                <span class="icon" aria-hidden="true">üîç</span>
                                <span class="sr-only">Open find widget</span>
                            </button>
                            <button class="btn btn-icon btn-secondary btn-icon-compact" onclick="openJSONPathWidget()" title="JSONPath (Alt+J)" data-tooltip="Open JSONPath mode (Alt+J)">
                                <span class="icon" aria-hidden="true">$.</span>
                                <span class="sr-only">Open JSONPath find widget</span>
                            </button>
                            <span class="search-actions__divider" role="presentation" aria-hidden="true"></span>
                            <button class="btn btn-icon btn-secondary btn-icon-compact" onclick="formatJSON()" title="Format JSON" data-tooltip="Pretty print JSON">
                                <span class="icon" aria-hidden="true">{ }</span>
                                <span class="sr-only">Format JSON</span>
                            </button>
                            <button class="btn btn-icon btn-secondary btn-icon-compact" onclick="minifyJSON()" title="Minify JSON" data-tooltip="Minify JSON">
                                <span class="icon" aria-hidden="true">‚ûñ</span>
                                <span class="sr-only">Minify JSON</span>
                            </button>
                            <button class="btn btn-icon btn-secondary btn-icon-compact" onclick="sortJSONKeys()" title="Sort keys (Ctrl+Alt+S)" data-tooltip="Sort keys alphabetically (Ctrl+Alt+S)">
                                <span class="icon" aria-hidden="true">üî§</span>
                                <span class="sr-only">Sort JSON keys</span>
                            </button>
                            <button class="btn btn-icon btn-secondary btn-icon-compact" onclick="collapseAllJSON()" title="Collapse all (Ctrl+Shift+[)" data-tooltip="Collapse all blocks (Ctrl+Shift+[)">
                                <span class="icon" aria-hidden="true">üìï</span>
                                <span class="sr-only">Collapse all JSON blocks</span>
                            </button>
                            <button class="btn btn-icon btn-secondary btn-icon-compact" onclick="expandAllJSON()" title="Expand all (Ctrl+Shift+])" data-tooltip="Expand all blocks (Ctrl+Shift+])">
                                <span class="icon" aria-hidden="true">üìñ</span>
                                <span class="sr-only">Expand all JSON blocks</span>
                            </button>
                            <button class="btn btn-icon btn-secondary btn-icon-compact" onclick="validateJSON()" title="Validate JSON" data-tooltip="Validate JSON">
                                <span class="icon" aria-hidden="true">‚úîÔ∏è</span>
                                <span class="sr-only">Validate JSON</span>
                            </button>
                            <span class="search-actions__divider" role="presentation" aria-hidden="true"></span>
                            <button class="btn btn-icon btn-secondary btn-icon-compact" onclick="openModal()" title="WireMock Templates" data-tooltip="WireMock templates">
                                <span class="icon" aria-hidden="true">üß©</span>
                                <span class="sr-only">WireMock templates</span>
                            </button>
                            <button class="btn btn-icon btn-secondary btn-icon-compact" onclick="openHistoryModal()" title="History" data-tooltip="Show history">
                                <span class="icon" aria-hidden="true">üïí</span>
                                <span class="sr-only">History</span>
                            </button>
                            <span class="search-actions__divider" role="presentation" aria-hidden="true"></span>
                            <button class="btn btn-icon btn-secondary btn-icon-compact" onclick="exportAsYAML()" title="Export as YAML" data-tooltip="Export YAML">
                                <span class="icon" aria-hidden="true">üì§</span>
                                <span class="sr-only">Export as YAML</span>
                            </button>
                        </div>
                    </div>
                </div>
                <div class="toolbar-side toolbar-side--right">
                    <div class="btn-group" id="editorControls" role="group" aria-label="Workspace actions">
                        <button class="btn btn-primary" onclick="updateMappingOnServer()" title="Update mapping" data-tooltip="Update existing mapping in WireMock">
                            <span class="icon" aria-hidden="true">üîÅ</span>
                            <span class="btn-label">Update</span>
                        </button>
                        <button class="btn btn-secondary" onclick="createMappingOnServer()" title="Create mapping" data-tooltip="Create new mapping in WireMock">
                            <span class="icon" aria-hidden="true">‚ú®</span>
                            <span class="btn-label">Create</span>
                        </button>
                        <button class="btn btn-secondary" onclick="newDocument()" title="Blank (Ctrl+N)" data-tooltip="New document (Ctrl+N)">
                            <span class="icon" aria-hidden="true">üìÑ</span>
                            <span class="btn-label">Blank</span>
                        </button>
                        <button class="btn btn-secondary" onclick="loadFile()" title="Upload (Ctrl+O)" data-tooltip="Upload JSON from file (Ctrl+O)">
                            <span class="icon" aria-hidden="true">üì•</span>
                            <span class="btn-label">Upload</span>
                        </button>
                        <button class="btn btn-secondary" onclick="downloadCurrentMapping()" title="Download (Ctrl+S)" data-tooltip="Download JSON (Ctrl+S)">
                            <span class="icon" aria-hidden="true">üíæ</span>
                            <span class="btn-label">Download</span>
                        </button>
                    </div>
                    <button class="btn btn-icon btn-secondary btn-icon-compact toolbar-theme-toggle" onclick="toggleTheme()" title="Toggle theme" data-tooltip="Toggle theme">
                        <span class="theme-icon" aria-hidden="true">üåô</span>
                        <span class="sr-only">Toggle theme</span>
                    </button>
                </div>
            </div>
        </section>
        <main class="editor-main">
            <div class="drag-overlay" id="dragOverlay">
                <div class="drag-text">
                    Drop JSON files here
                </div>
            </div>
            <div class="editor-container" id="editorContainer">
                <div id="jsonEditor" class="editor-surface"></div>
            </div>
            <div class="compare-container" id="compareContainer" style="display: none;">
                <div class="compare-panel">
                    <div id="compareEditorLeft" class="editor-surface"></div>
                </div>
                <div class="compare-panel">
                    <div id="compareEditorRight" class="editor-surface"></div>
                </div>
            </div>
        </main>
    </div>

    <!-- Templates Modal -->
    <div class="modal hidden" id="fullscreenModal" role="dialog" aria-modal="true" aria-labelledby="modal-title-templates" aria-hidden="true">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title-templates">WireMock Templates</h2>
                <button class="btn btn-icon" onclick="closeModal()" aria-label="Close templates modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="template-grid" id="templateGrid">
                <!-- Templates will be loaded here -->
            </div>
            </div>
        </div>
    </div>

    <div class="modal hidden" id="templatePreviewModal" role="dialog" aria-modal="true" aria-labelledby="modal-title-template-preview" aria-hidden="true">
        <div class="modal-content modal-content--wide">
            <div class="modal-header">
                <h2 id="modal-title-template-preview">Template preview</h2>
                <button class="btn btn-icon" onclick="closeModal('templatePreviewModal')" aria-label="Close template preview">&times;</button>
            </div>
            <div class="modal-body template-preview-body">
                <p class="template-preview-description" id="templatePreviewDescription"></p>
                <div class="template-preview-meta" id="templatePreviewMeta"></div>
                <pre class="template-preview-code" id="templatePreviewCode"></pre>
                <div class="template-preview-actions" id="templatePreviewActions">
                    <button class="btn btn-primary btn-sm" type="button" data-template-action="apply">Use template</button>
                    <button class="btn btn-secondary btn-sm" type="button" data-template-action="copy">Copy JSON</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal hidden modal--stacked" id="historyPreviewModal" role="dialog" aria-modal="true" aria-labelledby="modal-title-history-preview" aria-hidden="true">
        <div class="modal-content modal-content--wide">
            <div class="modal-header">
                <h2 id="modal-title-history-preview">Snapshot preview</h2>
                <button class="btn btn-icon" onclick="closeModal('historyPreviewModal')" aria-label="Close history preview">&times;</button>
            </div>
            <div class="modal-body history-preview-body">
                <div class="history-preview-meta" id="historyPreviewMeta"></div>
                <pre class="history-preview-summary" id="historyPreviewSummary"></pre>
                <pre class="history-preview-code" id="historyPreviewContent"></pre>
                <div class="history-preview-actions" id="historyPreviewActions">
                    <button class="btn btn-primary btn-sm" type="button" data-history-preview-action="restore">Restore</button>
                    <button class="btn btn-secondary btn-sm" type="button" data-history-preview-action="copy">Copy JSON</button>
                </div>
            </div>
        </div>
    </div>

    <!-- History Modal -->
    <div class="modal hidden" id="historyModal" role="dialog" aria-modal="true" aria-labelledby="modal-title-history" aria-hidden="true">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title-history">History</h2>
                <button class="btn btn-icon" onclick="closeHistoryModal()" aria-label="Close history modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="history-list" id="historyList">
                <!-- History items will be loaded here -->
            </div>
            </div>
        </div>
    </div>
    
    <div id="loadingOverlay" class="loading-overlay" aria-hidden="true">
        <div class="loading-spinner" role="status" aria-live="polite"></div>
    </div>
    
    <!-- Performance Optimization Scripts -->
    <script src="performance-optimizations.js"></script>
    
    <!-- Monaco Editor Loader (must be loaded first) -->
    <script>
        window.MONACO_CDN_SOURCES = [
            { label: 'jsDelivr', baseUrl: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.44.0/min/vs' },
            { label: 'cdnjs', baseUrl: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs' },
            { label: 'unpkg', baseUrl: 'https://unpkg.com/monaco-editor@0.44.0/min/vs' }
        ];

        const primaryMonacoSource = window.MONACO_CDN_SOURCES[0];
        const primaryMonacoBase = primaryMonacoSource && primaryMonacoSource.baseUrl
            ? primaryMonacoSource.baseUrl
            : 'https://cdn.jsdelivr.net/npm/monaco-editor@0.44.0/min/vs';

        window.require = window.require || {};
        window.require.paths = Object.assign({}, window.require.paths || {}, {
            vs: primaryMonacoBase.replace(/\/+$/, '')
        });
    </script>
    <script id="monaco-loader-script" src="https://cdn.jsdelivr.net/npm/monaco-editor@0.44.0/min/vs/loader.js"></script>
    <script>
        (function setupMonacoLoaderFallback() {
            const loaderScript = document.getElementById('monaco-loader-script');
            if (!loaderScript) {
                return;
            }

            const sources = Array.isArray(window.MONACO_CDN_SOURCES)
                ? window.MONACO_CDN_SOURCES.slice(1)
                : [];

            if (!sources.length) {
                return;
            }

            let attemptIndex = 0;

            const tryNext = () => {
                if (attemptIndex >= sources.length) {
                    console.error('Failed to load Monaco loader from all configured sources');
                    return;
                }

                const source = sources[attemptIndex++];
                if (!source || !source.baseUrl) {
                    tryNext();
                    return;
                }

                const baseUrl = source.baseUrl.replace(/\/+$/, '');
                window.require = window.require || {};
                window.require.paths = Object.assign({}, window.require.paths || {}, { vs: baseUrl });

                const fallbackScript = document.createElement('script');
                fallbackScript.src = `${baseUrl}/loader.js`;
                fallbackScript.async = false;
                fallbackScript.dataset.monacoLoader = source.label || baseUrl;
                fallbackScript.onerror = tryNext;

                document.head.appendChild(fallbackScript);
            };

            loaderScript.onerror = () => {
                loaderScript.onerror = null;
                tryNext();
            };
        })();
    </script>
    
    <!-- WireMock URL initialization - moved to initializeFromURL -->

    <!-- WireMock Integration -->
    <script src="../js/main.js"></script>
    <script src="../js/core.js"></script>
    <script src="../js/managers.js"></script>
    <script src="../js/features.js"></script>

    <!-- Monaco Enhanced (our main editor) -->
    <script src="monaco-enhanced.js"></script>

    <script>
        const editorUrlParams = new URLSearchParams(window.location.search);
        const initialMappingId = (editorUrlParams.get('mappingId') || '').trim() || null;

        const editorMappingContext = {
            initialMappingId,
            lastKnownId: initialMappingId,
            getFallbackId() {
                return this.lastKnownId || this.initialMappingId || null;
            },
            remember(id) {
                if (!id) return;
                const trimmed = String(id).trim();
                if (!trimmed) return;
                this.lastKnownId = trimmed;
            }
        };

        window.editorMappingContext = editorMappingContext;
        window.rememberEditorMappingId = (id) => editorMappingContext.remember(id);

        function resolveMappingIdentifier(mapping) {
            if (!mapping || typeof mapping !== 'object') {
                return null;
            }

            const id = mapping.id || mapping.uuid;
            return id && String(id).trim() ? String(id).trim() : null;
        }

        /**
         * Show notification
         */
        function showNotification(message, type = 'info') {
            const manager = window.NotificationManager;
            const normalizedType = (type || 'info').toString().toLowerCase();

            if (manager && typeof manager.show === 'function') {
                try {
                    if (typeof manager[normalizedType] === 'function') {
                        manager[normalizedType](message);
                    } else {
                        manager.show(message, normalizedType);
                    }
                    return;
                } catch (error) {
                    console.warn('NotificationManager failed, falling back to console log:', error);
                }
            }

            const label = normalizedType.toUpperCase();
            console.log(`[${label}] ${message}`);
        }

        /**
         * Save to history (editor-specific implementation)
         */
        function saveToHistory(content, action) {
            try {
                if (!window.monacoInitializer || typeof window.monacoInitializer.recordHistorySnapshot !== 'function') {
                    console.log(`[HISTORY] ${action || 'snapshot'}: history service unavailable`);
                    return;
                }

                const serialized = typeof content === 'string'
                    ? content
                    : JSON.stringify(content, null, 2);

                window.monacoInitializer.recordHistorySnapshot(action || 'Manual snapshot', {
                    label: action || 'Manual snapshot',
                    manual: true,
                    force: true,
                    contentOverride: serialized
                });
                window.monacoInitializer.refreshHistoryUI({ force: true });
            } catch (error) {
                console.warn('History save failed:', error);
            }
        }

        /**
         * Apply optimistic mapping update to local cache if available
         */
        function applyOptimisticMappingUpdateLocally(mappingData) {
            try {
                console.log('üéØ [OPTIMISTIC] Applying optimistic update locally:', mappingData.id);

                // Try to update local cache if available
                if (typeof window.applyOptimisticMappingUpdate === 'function') {
                    console.log('üéØ [OPTIMISTIC] Using local applyOptimisticMappingUpdate');

                    // In editor context, we only update cache without rendering
                    try {
                        if (!mappingData) return;
                        const m = mappingData.mapping || mappingData;
                        if (!m || !m.id) return;
                        if (!Array.isArray(window.allMappings)) window.allMappings = [];
                        if (!Array.isArray(window.originalMappings)) window.originalMappings = [];

                        // drop service cache mapping if ever present
                        if (typeof isImockCacheMapping === 'function' && isImockCacheMapping(m)) return; // never render the service mapping

                        // Update or add entry in allMappings
                        const idx = window.allMappings.findIndex(x => (x.id || x.uuid) === (m.id || m.uuid));
                        if (idx >= 0) {
                            window.allMappings[idx] = m;
                        } else {
                            window.allMappings.unshift(m);
                        }

                        // Update originalMappings as well for consistency
                        const origIdx = window.originalMappings.findIndex(x => (x.id || x.uuid) === (m.id || m.uuid));
                        if (origIdx >= 0) {
                            window.originalMappings[origIdx] = m;
                        } else {
                            window.originalMappings.unshift(m);
                        }

                        console.log('üéØ [OPTIMISTIC] Cache updated successfully in editor context');
                        console.log('üéØ [OPTIMISTIC] Updated mapping:', m.name || m.id);
                        console.log('üéØ [OPTIMISTIC] allMappings size:', window.allMappings.length);
                        return true;
                    } catch (e) {
                        console.warn('üéØ [OPTIMISTIC] Local cache update failed, trying main function:', e);
                        // Fallback to main function
                        window.applyOptimisticMappingUpdate(mappingData);
                        console.log('üéØ [OPTIMISTIC] Local update applied successfully');
                        return true;
                    }
                }

                // Fallback: try to update via postMessage to parent
                if (window.parent && window.parent !== window) {
                    try {
                        console.log('üéØ [OPTIMISTIC] Sending optimistic update via postMessage to parent');
                        console.log('üéØ [OPTIMISTIC] Mapping data:', { id: mappingData.id, name: mappingData.name });
                        window.parent.postMessage({
                            type: 'imock-optimistic-mapping-update',
                            mapping: mappingData,
                            source: 'json-editor',
                            timestamp: Date.now()
                        }, '*');
                        console.log('üéØ [OPTIMISTIC] PostMessage sent successfully');
                        return true;
                    } catch (e) {
                        console.warn('üéØ [OPTIMISTIC] Parent postMessage failed:', e);
                    }
                }

                // Fallback: try BroadcastChannel
                if (typeof BroadcastChannel !== 'undefined') {
                    try {
                        console.log('üéØ [OPTIMISTIC] Sending optimistic update via BroadcastChannel');
                        console.log('üéØ [OPTIMISTIC] BroadcastChannel mapping data:', { id: mappingData.id, name: mappingData.name });
                        const channel = new BroadcastChannel('imock-optimistic-updates');
                        channel.postMessage({
                            type: 'optimistic-mapping-update',
                            mapping: mappingData,
                            source: 'json-editor',
                            timestamp: Date.now()
                        });
                        channel.close();
                        console.log('üéØ [OPTIMISTIC] BroadcastChannel message sent successfully');
                        return true;
                    } catch (e) {
                        console.warn('üéØ [OPTIMISTIC] BroadcastChannel failed:', e);
                    }
                }

                console.log('‚ö†Ô∏è No method available for optimistic update');
                return false;
            } catch (error) {
                console.warn('Error applying optimistic update locally:', error);
                return false;
            }
        }

        /**
         * Try to refresh cache in parent window or broadcast to all windows
         */
        function tryRefreshParentCache() {
            try {
                console.log('üîÑ Attempting to refresh cache in parent/all windows...');

                // Method 1: Direct call to parent window (popup scenario)
                if (window.opener && typeof window.opener.refreshImockCache === 'function') {
                    console.log('üîÑ Refreshing cache via direct parent call...');
                    window.opener.refreshImockCache().catch(error => {
                        console.warn('Failed to refresh cache in parent window:', error);
                    });
                    return;
                }

                // Method 2: Try parent window via postMessage
                if (window.parent && window.parent !== window) {
                    try {
                        console.log('üîÑ Refreshing cache via parent postMessage...');
                        window.parent.postMessage({
                            type: 'imock-cache-refresh',
                            source: 'json-editor',
                            timestamp: Date.now()
                        }, '*');
                    } catch (e) {
                        console.warn('Parent postMessage failed:', e);
                    }
                }

                // Method 3: Broadcast to all windows via localStorage (cross-tab communication)
                try {
                    console.log('üîÑ Refreshing cache via localStorage broadcast...');
                    localStorage.setItem('imock-cache-refresh-trigger', Date.now().toString());
                    // Clean up immediately to avoid spam
                    setTimeout(() => {
                        localStorage.removeItem('imock-cache-refresh-trigger');
                    }, 100);
                } catch (e) {
                    console.warn('localStorage broadcast failed:', e);
                }

                // Method 4: Try BroadcastChannel API (modern browsers)
                if (typeof BroadcastChannel !== 'undefined') {
                    try {
                        console.log('üîÑ Refreshing cache via BroadcastChannel...');
                        const channel = new BroadcastChannel('imock-cache-refresh');
                        channel.postMessage({
                            type: 'cache-refresh',
                            source: 'json-editor',
                            timestamp: Date.now()
                        });
                        channel.close();
                    } catch (e) {
                        console.warn('BroadcastChannel failed:', e);
                    }
                }

                // Method 5: Try to find main window by iterating through window frames
                try {
                    if (window.top && window.top !== window) {
                        const frames = window.top.frames;
                        for (let i = 0; i < frames.length; i++) {
                            try {
                                const frame = frames[i];
                                if (frame && typeof frame.refreshImockCache === 'function') {
                                    console.log('üîÑ Refreshing cache via frame iteration...');
                                    frame.refreshImockCache().catch(e => console.warn('Frame refresh failed:', e));
                                }
                            } catch (e) {
                                // Ignore cross-origin errors
                            }
                        }
                    }
                } catch (e) {
                    console.warn('Frame iteration failed:', e);
                }

                console.log('üîÑ Cache refresh attempts completed');
            } catch (error) {
                console.warn('Error trying to refresh parent cache:', error);
            }
        }

        /**
         * Download file (editor-specific implementation)
         */
        function downloadFile(content, filename, mimeType) {
            try {
                const blob = new Blob([content], { type: mimeType || 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showNotification(`File downloaded: ${filename}`, 'success');
            } catch (error) {
                console.error('Download failed:', error);
                showNotification('Download failed: ' + error.message, 'error');
            }
        }

        /**
         * Modal helpers
         */
        const MODAL_FOCUSABLE_SELECTORS = [
            'button:not([disabled])',
            'a[href]',
            'input:not([disabled])',
            'select:not([disabled])',
            'textarea:not([disabled])',
            '[tabindex]:not([tabindex="-1"])'
        ].join(', ');

        function tryFocusElement(element) {
            if (!element || typeof element.focus !== 'function') {
                return;
            }

            try {
                element.focus({ preventScroll: true });
            } catch (e) {
                element.focus();
            }
        }

        function setModalVisibility(modal, shouldShow) {
            if (!(modal instanceof HTMLElement)) {
                return;
            }

            if (shouldShow) {
                modal.classList.remove('hidden');
                modal.classList.add('show');
                modal.style.display = 'flex';
                modal.setAttribute('aria-hidden', 'false');

                if (!modal.__triggerElement && document.activeElement instanceof HTMLElement) {
                    modal.__triggerElement = document.activeElement;
                }

                document.body.classList.add('modal-open');

                const focusTarget = modal.querySelector('[data-autofocus]') || modal.querySelector(MODAL_FOCUSABLE_SELECTORS);
                if (focusTarget) {
                    tryFocusElement(focusTarget);
                } else {
                    modal.setAttribute('tabindex', '-1');
                    tryFocusElement(modal);
                }
            } else {
                const trigger = modal.__triggerElement instanceof HTMLElement ? modal.__triggerElement : null;
                const activeElement = document.activeElement instanceof HTMLElement ? document.activeElement : null;
                const hadFocusInside = activeElement ? modal.contains(activeElement) : false;

                if (hadFocusInside) {
                    if (trigger) {
                        tryFocusElement(trigger);
                    } else if (activeElement && typeof activeElement.blur === 'function') {
                        activeElement.blur();
                    }
                }

                modal.classList.remove('show');
                modal.classList.add('hidden');
                modal.style.display = 'none';
                modal.setAttribute('aria-hidden', 'true');

                delete modal.__triggerElement;

                if (!document.querySelector('.modal.show, .modal[aria-hidden="false"]')) {
                    document.body.classList.remove('modal-open');
                }

                if (!hadFocusInside && trigger) {
                    tryFocusElement(trigger);
                }
            }
        }

        function openModal(modalId = 'fullscreenModal') {
            const modal = document.getElementById(modalId);
            if (!modal) {
                console.warn(`Modal with id "${modalId}" not found`);
                return;
            }

            if (modalId === 'fullscreenModal' && typeof window.renderTemplateLibrary === 'function') {
                window.renderTemplateLibrary();
            }

            if (modalId === 'historyModal' && typeof window.renderHistoryModal === 'function') {
                window.renderHistoryModal();
            }

            setModalVisibility(modal, true);
        }

        function closeModal(modalId = 'fullscreenModal') {
            const modal = document.getElementById(modalId);
            if (!modal) {
                console.warn(`Modal with id "${modalId}" not found`);
                return;
            }

            setModalVisibility(modal, false);
        }

        function openHistoryModal() {
            openModal('historyModal');
        }

        function closeHistoryModal() {
            closeModal('historyModal');
        }

        /**
         * Toggle theme
         */
        function toggleTheme() {
            const body = document.body;
            const currentTheme = body.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            body.setAttribute('data-theme', newTheme);

            const themeIcon = document.querySelector('.theme-icon');
            if (themeIcon) {
                themeIcon.textContent = newTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
            }

            localStorage.setItem('theme', newTheme);
            showNotification(`Switched to ${newTheme} theme`, 'success');
        }

        function newDocument() {
            try {
                if (window.monacoInitializer && typeof window.monacoInitializer.newDocument === 'function') {
                    window.monacoInitializer.newDocument();
                    const editor = window.monacoInitializer.getActiveEditor ? window.monacoInitializer.getActiveEditor() : null;
                    if (editor && typeof editor.getValue === 'function' && typeof saveToHistory === 'function') {
                        saveToHistory(editor.getValue(), 'New document');
                    }
                } else {
                    showNotification('New document action not available', 'error');
                }
            } catch (error) {
                console.error('New document error:', error);
                showNotification('Error creating new document: ' + error.message, 'error');
            }
        }

        function clearComparePanel(side) {
            const target = side || 'both';
            try {
                if (window.monacoInitializer && typeof window.monacoInitializer.clearCompareContent === 'function') {
                    window.monacoInitializer.clearCompareContent(target);
                } else {
                    showNotification('Clear panel action not available', 'error');
                }
            } catch (error) {
                console.error('Clear panel error:', error);
                showNotification('Error clearing panel: ' + error.message, 'error');
            }
        }

        function exportAsYAML() {
            try {
                if (window.monacoInitializer && typeof window.monacoInitializer.exportAsYAML === 'function') {
                    window.monacoInitializer.exportAsYAML();
                } else {
                    showNotification('Export to YAML is not available', 'error');
                }
            } catch (error) {
                console.error('Export YAML error:', error);
                showNotification('Export YAML error: ' + error.message, 'error');
            }
        }

        /**
         * Switch mode between editor and compare
         */
        function switchMode(mode) {
            const editorContainer = document.getElementById('editorContainer');
            const compareContainer = document.getElementById('compareContainer');
            const editorControls = document.getElementById('editorControls');
            const compareControls = document.getElementById('compareControls');
            const modeTabs = document.querySelectorAll('.mode-tab');
            
            modeTabs.forEach(tab => {
                tab.classList.remove('active');
                if (tab.dataset.mode === mode) {
                    tab.classList.add('active');
                }
            });
            
            if (mode === 'compare') {
                editorContainer.style.display = 'none';
                compareContainer.style.display = 'flex';
                editorControls.style.display = 'none';
                compareControls.style.display = 'flex';
            } else {
                editorContainer.style.display = 'block';
                compareContainer.style.display = 'none';
                editorControls.style.display = 'flex';
                compareControls.style.display = 'none';
            }
            
            showNotification(`Switched to ${mode} mode`, 'success');
        }

        /**
         * Trigger Monaco find widget
         */
        function triggerFindWidget(mode = 'text') {
            try {
                if (window.monacoInitializer && typeof window.monacoInitializer.openFindWidget === 'function') {
                    const options = {
                        focus: true,
                        select: true
                    };

                    if (mode === 'jsonpath') {
                        options.jsonPathMode = true;
                    } else if (mode === 'text') {
                        options.jsonPathMode = false;
                    }

                    const result = window.monacoInitializer.openFindWidget(options);
                    if (result && typeof result.then === 'function') {
                        result.catch(error => {
                            console.error('Find widget error:', error);
                            showNotification('Find widget error: ' + error.message, 'error');
                        });
                    }
                } else {
                    showNotification('Find widget is not available', 'error');
                }
            } catch (error) {
                console.error('Find widget error:', error);
                showNotification('Find widget error: ' + error.message, 'error');
            }
        }

        /**
         * Open regular find widget
         */
        function openTextFindWidget() {
            triggerFindWidget('text');
        }

        /**
         * Open find widget in JSONPath mode
         */
        function openJSONPathWidget() {
            triggerFindWidget('jsonpath');
        }

        // Backwards compatibility for legacy handlers
        function searchJSONPath() {
            openJSONPathWidget();
        }

        /**
         * Format JSON
         */
        function formatJSON() {
            try {
                        if (window.monacoInitializer && typeof window.monacoInitializer.formatJSON === 'function') {
                            const currentContent = window.editor ? window.editor.getValue() : '';
                            window.monacoInitializer.formatJSON();
                            setTimeout(() => {
                                if (window.editor) {
                                    const newContent = window.editor.getValue();
                                    if (newContent !== currentContent) {
                                        saveToHistory(newContent, 'JSON Formatted');
                                        showNotification('JSON formatted', 'success');
                                    }
                                }
                            }, 100);
                } else {
                    showNotification('Format function not available', 'error');
                }
            } catch (error) {
                console.error('Format error:', error);
                showNotification('Format error: ' + error.message, 'error');
            }
        }

        /**
         * Minify JSON
         */
        function minifyJSON() {
            try {
                        if (window.monacoInitializer && typeof window.monacoInitializer.minifyJSON === 'function') {
                            const currentContent = window.editor ? window.editor.getValue() : '';
                            window.monacoInitializer.minifyJSON();
                            setTimeout(() => {
                                if (window.editor) {
                                    const newContent = window.editor.getValue();
                                    if (newContent !== currentContent) {
                                        saveToHistory(newContent, 'JSON Minified');
                                        showNotification('JSON minified', 'success');
                                    }
                                }
                            }, 100);
                } else {
                    showNotification('Minify function not available', 'error');
                }
            } catch (error) {
                console.error('Minify error:', error);
                showNotification('Minify error: ' + error.message, 'error');
            }
        }

        function sortJSONKeys() {
            try {
                if (window.monacoInitializer && typeof window.monacoInitializer.sortJSONKeys === 'function') {
                    const editor = window.monacoInitializer.getActiveEditor ? window.monacoInitializer.getActiveEditor() : null;
                    const currentContent = editor && typeof editor.getValue === 'function' ? editor.getValue() : '';
                    window.monacoInitializer.sortJSONKeys();
                    setTimeout(() => {
                        if (editor && typeof editor.getValue === 'function') {
                            const newContent = editor.getValue();
                            if (newContent !== currentContent) {
                                saveToHistory(newContent, 'JSON Keys Sorted');
                                showNotification('JSON keys sorted', 'success');
                            }
                        }
                    }, 100);
                } else {
                    showNotification('Sort keys function not available', 'error');
                }
            } catch (error) {
                console.error('Sort keys error:', error);
                showNotification('Sort keys error: ' + error.message, 'error');
            }
        }

        function collapseAllJSON() {
            try {
                if (window.monacoInitializer && typeof window.monacoInitializer.collapseAllFolds === 'function') {
                    window.monacoInitializer.collapseAllFolds({ focus: true });
                } else {
                    showNotification('Collapse all is not available', 'error');
                }
            } catch (error) {
                console.error('Collapse JSON error:', error);
                showNotification('Collapse JSON error: ' + error.message, 'error');
            }
        }

        function expandAllJSON() {
            try {
                if (window.monacoInitializer && typeof window.monacoInitializer.expandAllFolds === 'function') {
                    window.monacoInitializer.expandAllFolds({ focus: true });
                } else {
                    showNotification('Expand all is not available', 'error');
                }
            } catch (error) {
                console.error('Expand JSON error:', error);
                showNotification('Expand JSON error: ' + error.message, 'error');
            }
        }

        /**
         * Validate JSON
         */
        function validateJSON() {
            try {
                if (window.monacoInitializer && typeof window.monacoInitializer.validateJSON === 'function') {
                    window.monacoInitializer.validateJSON();
                } else {
                    showNotification('Validate function not available', 'error');
                }
            } catch (error) {
                console.error('Validate error:', error);
                showNotification('Validate error: ' + error.message, 'error');
            }
        }

        /**
         * Load compare file
         */
        function loadCompareFile(side) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const content = e.target.result;
                            if (window.monacoInitializer && typeof window.monacoInitializer.loadCompareContent === 'function') {
                                window.monacoInitializer.loadCompareContent(side, content);
                            } else {
                                showNotification('Compare function not available', 'error');
                            }
                        } catch (error) {
                            showNotification('Error loading file: ' + error.message, 'error');
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        /**
         * Download current editor content
         */
        function downloadCurrentMapping() {
            try {
                if (window.monacoInitializer && typeof window.monacoInitializer.saveFile === 'function') {
                    window.monacoInitializer.saveFile();
                    return;
                }

                const editor = window.monacoInitializer && typeof window.monacoInitializer.getActiveEditor === 'function'
                    ? window.monacoInitializer.getActiveEditor()
                    : null;
                const content = editor && typeof editor.getValue === 'function' ? editor.getValue() : '';

                if (!content) {
                    showNotification('No content available for download', 'warning');
                    return;
                }

                downloadFile(content, 'wiremock-mapping.json', 'application/json');
                showNotification('File downloaded', 'success');
            } catch (error) {
                console.error('Download error:', error);
                showNotification('Download error: ' + error.message, 'error');
            }
        }

        function getMappingFromEditorSnapshot() {
            if (!window.monacoInitializer || typeof window.monacoInitializer.getMappingFromEditor !== 'function') {
                showNotification('Editor not ready for mapping operations', 'error');
                return null;
            }

            const mapping = window.monacoInitializer.getMappingFromEditor();
            if (!mapping) {
                showNotification('No valid JSON to process', 'warning');
                return null;
            }

            return mapping;
        }

        function normalizeMappingIdentifiers(mapping) {
            if (!mapping || typeof mapping !== 'object') {
                return;
            }

            if (typeof mapping.id === 'string') {
                const trimmed = mapping.id.trim();
                if (trimmed) {
                    mapping.id = trimmed;
                } else {
                    delete mapping.id;
                }
            }

            if (typeof mapping.uuid === 'string') {
                const trimmed = mapping.uuid.trim();
                if (trimmed) {
                    mapping.uuid = trimmed;
                } else {
                    delete mapping.uuid;
                }
            }
        }

        function ensureMappingMetadata(mapping, { isCreate } = {}) {
            if (!mapping || typeof mapping !== 'object') {
                return;
            }

            const nowIso = new Date().toISOString();
            if (!mapping.metadata || typeof mapping.metadata !== 'object') {
                mapping.metadata = {};
            }

            if (isCreate && !mapping.metadata.created) {
                mapping.metadata.created = nowIso;
            } else if (!mapping.metadata.created) {
                mapping.metadata.created = nowIso;
            }

            mapping.metadata.edited = nowIso;
            mapping.metadata.source = 'editor';
        }

        function propagateMappingUpdate(mappingData) {
            if (!mappingData) {
                return;
            }

            applyOptimisticMappingUpdateLocally(mappingData);

            if (window.opener && typeof window.opener.applyOptimisticMappingUpdate === 'function') {
                try {
                    window.opener.applyOptimisticMappingUpdate(mappingData);
                } catch (error) {
                    console.warn('Failed to push optimistic update to opener:', error);
                }
            } else if (window.opener) {
                try {
                    window.opener.postMessage({
                        type: 'imock-optimistic-mapping-update',
                        mapping: mappingData,
                        source: 'json-editor-save',
                        timestamp: Date.now()
                    }, '*');
                } catch (error) {
                    console.warn('Failed to postMessage optimistic update to opener:', error);
                }
            }
        }

        function buildDownloadFilename(mapping, suffix = 'wiremock-mapping') {
            const base = mapping && mapping.name ? String(mapping.name) : suffix;
            const normalized = base.toLowerCase().replace(/[^a-z0-9-_]+/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
            return (normalized || suffix) + '.json';
        }

        async function executeWireMockOperation(mapping, { mode, targetId }) {
            const editor = window.monacoInitializer && typeof window.monacoInitializer.getActiveEditor === 'function'
                ? window.monacoInitializer.getActiveEditor()
                : null;

            if (editor) {
                editor.updateOptions({ readOnly: true });
            }

            const serialized = JSON.stringify(mapping, null, 2);

            try {
                if (!window.apiFetch || !window.wiremockBaseUrl) {
                    throw new Error('WireMock is not connected');
                }

                const endpoint = mode === 'update' ? `/mappings/${encodeURIComponent(targetId)}` : '/mappings';
                const method = mode === 'update' ? 'PUT' : 'POST';
                const response = await window.apiFetch(endpoint, {
                    method,
                    headers: { 'Content-Type': 'application/json' },
                    body: serialized
                });

                const payload = response?.mapping || response;
                const successMessage = mode === 'update'
                    ? `Mapping ${targetId || payload?.id} updated successfully`
                    : `Mapping ${payload?.id || mapping.name || 'new mapping'} created successfully`;

                showNotification(successMessage, 'success');
                propagateMappingUpdate(payload || mapping);

                const rememberedId = resolveMappingIdentifier(payload) || resolveMappingIdentifier(mapping);
                if (rememberedId) {
                    editorMappingContext.remember(rememberedId);
                }

                return payload;
            } catch (error) {
                console.error('WireMock operation failed:', error);
                const filename = buildDownloadFilename(mapping, mode === 'update' ? 'wiremock-update' : 'wiremock-create');
                downloadFile(serialized, filename, 'application/json');
                saveToHistory(serialized, mode === 'update' ? 'Saved as download (update fallback)' : 'Saved as download (create fallback)');
                showNotification('WireMock unavailable, mapping downloaded instead', 'warning');
                return null;
            } finally {
                if (editor) {
                    editor.updateOptions({ readOnly: false });
                }
            }
        }

        async function updateMappingOnServer() {
            const mapping = getMappingFromEditorSnapshot();
            if (!mapping) {
                return;
            }

            normalizeMappingIdentifiers(mapping);

            let targetId = resolveMappingIdentifier(mapping);
            if (targetId) {
                const confirmed = window.confirm(`Update mapping ${targetId}? Current data on the server will be replaced.`);
                if (!confirmed) {
                    showNotification('Update cancelled', 'info');
                    return;
                }
            } else {
                const fallbackId = editorMappingContext.getFallbackId();
                if (!fallbackId) {
                    showNotification('Cannot update mapping: no identifier available', 'error');
                    return;
                }

                const confirmed = window.confirm(`The JSON does not contain an id. Use cached id ${fallbackId} for update?`);
                if (!confirmed) {
                    showNotification('Update cancelled', 'info');
                    return;
                }

                mapping.id = fallbackId;
                if (!mapping.uuid) {
                    mapping.uuid = fallbackId;
                }
                targetId = fallbackId;
            }

            if (mapping.uuid && !mapping.id) {
                mapping.id = mapping.uuid;
            }

            ensureMappingMetadata(mapping, { isCreate: false });
            editorMappingContext.remember(targetId);

            await executeWireMockOperation(mapping, { mode: 'update', targetId });
        }

        async function createMappingOnServer() {
            const mapping = getMappingFromEditorSnapshot();
            if (!mapping) {
                return;
            }

            normalizeMappingIdentifiers(mapping);

            const label = mapping.name || mapping.request?.url || mapping.request?.urlPath || 'new mapping';
            const confirmed = window.confirm(`Create a new mapping "${label}" in WireMock?`);
            if (!confirmed) {
                showNotification('Creation cancelled', 'info');
                return;
            }

            ensureMappingMetadata(mapping, { isCreate: true });

            const result = await executeWireMockOperation(mapping, { mode: 'create' });
            const rememberedId = resolveMappingIdentifier(result) || resolveMappingIdentifier(mapping);
            if (rememberedId) {
                editorMappingContext.remember(rememberedId);
            }
        }

        /**
         * Load file or mapping
         */
        function loadFile() {
            try {
                // Try WireMock integration first
                if (typeof WireMockManager !== 'undefined' && WireMockManager.isConnected()) {
                    const choice = confirm('Load from WireMock server or from local file?\nOK = WireMock Server\nCancel = Local File');
                    
                    if (choice) {
                        // Load from WireMock
                        WireMockManager.getAllMappings()
                            .then(mappings => {
                                if (mappings && mappings.length > 0) {
                                    // Show mapping selection modal or load first mapping
                                    const firstMapping = mappings[0];
                                    if (window.monacoInitializer && typeof window.monacoInitializer.loadMappingIntoEditor === 'function') {
                                        window.monacoInitializer.loadMappingIntoEditor(firstMapping);
                                        showNotification(`Loaded mapping: ${firstMapping.name || 'Unnamed'}`, 'success');
                                    }
                                } else {
                                    showNotification('No mappings found in WireMock', 'warning');
                                }
                            })
                            .catch(error => {
                                console.error('WireMock load failed:', error);
                                showNotification('Failed to load from WireMock: ' + error.message, 'error');
                            });
                        return;
                    }
                }
                
                // Load from local file
                if (window.monacoInitializer && typeof window.monacoInitializer.loadFile === 'function') {
                    window.monacoInitializer.loadFile();
                } else {
                    showNotification('Load function not available', 'error');
                }
            } catch (error) {
                console.error('Load error:', error);
                showNotification('Load error: ' + error.message, 'error');
            }
        }


        // Close modals when clicking outside
        document.addEventListener('click', (e) => {
            const target = e.target;
            if (target instanceof HTMLElement && target.classList.contains('modal') && target.getAttribute('aria-hidden') === 'false') {
                setModalVisibility(target, false);
            }
        });

        // Close modals with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const openModal = document.querySelector('.modal.show, .modal[aria-hidden="false"]');
                if (openModal instanceof HTMLElement) {
                    e.preventDefault();
                    setModalVisibility(openModal, false);
                }
            }
        });

        /**
         * Toggle performance monitoring display
         */
        function togglePerformanceMonitoring() {
            if (window.monacoInitializer && typeof window.monacoInitializer.showPerformanceBadge === 'function') {
                window.monacoInitializer.showPerformanceBadge();
                showNotification('Performance monitoring enabled', 'info');
            } else {
                showNotification('Performance monitoring not available', 'warning');
            }
        }

        /**
         * Get health statistics
         */
        function getHealthStats() {
            if (window.monacoInitializer && typeof window.monacoInitializer.getHealthStats === 'function') {
                const stats = window.monacoInitializer.getHealthStats();
                console.log('Health Stats:', stats);
                showNotification('Health stats logged to console', 'info');
                return stats;
            } else {
                showNotification('Health monitoring not available', 'warning');
                return null;
            }
        }

        /**
         * Test optimistic update functionality
         */
        function testOptimisticUpdate() {
            console.log('üß™ [TEST] Testing optimistic update functionality');

            // Get current mapping ID from URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            const currentMappingId = urlParams.get('mappingId');

            if (!currentMappingId) {
                console.warn('üß™ [TEST] No mapping ID found in URL, cannot test update');
                showNotification('Cannot test optimistic update - no mapping ID in URL', 'warning');
                return;
            }

            // Get current mapping data from editor
            let currentMapping;
            try {
                if (window.monacoInitializer && typeof window.monacoInitializer.getMappingFromEditor === 'function') {
                    currentMapping = window.monacoInitializer.getMappingFromEditor();
                }
            } catch (e) {
                console.warn('üß™ [TEST] Could not get mapping from editor:', e);
            }

            if (!currentMapping) {
                console.warn('üß™ [TEST] Could not retrieve current mapping data');
                showNotification('Cannot test optimistic update - failed to get current mapping', 'warning');
                return;
            }

            // Create a modified version of the current mapping for testing
            const testMapping = {
                ...currentMapping,
                id: currentMappingId,
                name: currentMapping.name + ' [OPTIMISTIC UPDATE ' + new Date().toLocaleTimeString() + ']',
                response: {
                    ...currentMapping.response,
                    jsonBody: {
                        ...currentMapping.response?.jsonBody,
                        _testUpdate: true,
                        _timestamp: new Date().toISOString()
                    }
                },
                metadata: {
                    ...currentMapping.metadata,
                    edited: new Date().toISOString(), // Update edited timestamp for test
                    source: 'editor-test'
                }
            };

            console.log('üß™ [TEST] Test mapping update created:', testMapping);

            // Test local optimistic update (updates editor's local arrays)
            const localResult = applyOptimisticMappingUpdateLocally(testMapping);
            console.log('üß™ [TEST] Local optimistic update result:', localResult);

            // Test direct call to main window's applyOptimisticMappingUpdate (if available)
            if (window.opener && typeof window.opener.applyOptimisticMappingUpdate === 'function') {
                try {
                    console.log('üéØ [TEST] Calling applyOptimisticMappingUpdate directly on opener...');
                    window.opener.applyOptimisticMappingUpdate(testMapping);
                    console.log('üéØ [TEST] Direct call to opener completed');
                } catch (e) {
                    console.warn('üéØ [TEST] Direct call to opener failed:', e);
                }
            } else {
                console.log('üéØ [TEST] Opener not available or function not found, trying postMessage...');
                // Fallback: try postMessage to parent/opener
                if (window.opener) {
                    try {
                        window.opener.postMessage({
                            type: 'imock-optimistic-mapping-update',
                            mapping: testMapping,
                            source: 'json-editor-test',
                            timestamp: Date.now()
                        }, '*');
                        console.log('üéØ [TEST] postMessage to opener sent');
                    } catch (e) {
                        console.warn('üéØ [TEST] postMessage to opener failed:', e);
                    }
                }
            }

            showNotification('Optimistic update test completed - check console logs and main window', 'info');
        }

        /**
         * Test cache refresh functionality
         */
        function testCacheRefresh() {
            console.log('üß™ [TEST] Testing cache refresh functionality');

            // Test cache refresh
            tryRefreshParentCache();
            console.log('üß™ [TEST] Cache refresh triggered');

            showNotification('Cache refresh test completed - check console logs and main window', 'info');
        }

        console.log('‚úÖ WireMock JSON Studio loaded with modal implementations');
        
        /**
         * Initialize URL parameters and load mapping if specified
         */
        function initializeFromURL() {
            if (window.initializedFromURL) {
                console.log('üöÄ initializeFromURL already called, skipping');
                return;
            }

            console.log('üöÄ initializeFromURL called');
            console.log('üöÄ Current URL:', window.location.href);
            console.log('üöÄ URL search params:', window.location.search);

            // WireMock URL initialization - single entry point
            const urlParams = new URLSearchParams(window.location.search);
            const settingsParam = urlParams.get('settings');
            const settings = settingsParam
                ? JSON.parse(decodeURIComponent(settingsParam))
                : JSON.parse(localStorage.getItem('wiremock-settings') || '{}');

            const host = settings.host || 'localhost';
            const port = settings.port || '8080';

            window.wiremockBaseUrl = window.normalizeWiremockBaseUrl
                ? window.normalizeWiremockBaseUrl(host, port)
                : `http://${host}:${port}/__admin`;

            console.log('‚úÖ WireMock URL initialized in initializeFromURL:', window.wiremockBaseUrl);

            const mappingId = urlParams.get('mappingId');
            const mode = urlParams.get('mode');

            console.log('üöÄ Parsed parameters:', { mappingId, mode, settings: settings ? 'present' : 'missing' });

            if (mappingId) {
                console.log(`üîç Loading mapping with ID: ${mappingId}`);
                loadMappingById(mappingId);
            } else {
                console.log('‚ö†Ô∏è No mappingId found in URL parameters');
            }

            if (mode) {
                console.log(`üîß Setting mode to: ${mode}`);
                // Set mode if specified
                if (mode === 'compare') {
                    switchMode('compare');
                }
            }

            window.initializedFromURL = true;
        }
        
        /**
         * Load mapping by ID from WireMock
         */
        async function loadMappingById(mappingId) {
            try {
                console.log('üîç loadMappingById called with mappingId:', mappingId);
                console.log('üîç Current window.wiremockBaseUrl:', window.wiremockBaseUrl);
                console.log('üîç window.getMappingById available:', typeof window.getMappingById);

                showNotification('Loading mapping...', 'info');

                // Clear any existing content while the mapping loads without polluting history
                if (window.monacoInitializer && typeof window.monacoInitializer.prepareEditorForMappingLoad === 'function') {
                    window.monacoInitializer.prepareEditorForMappingLoad(mappingId);
                } else if (window.monacoInitializer && window.monacoInitializer.isInitialized) {
                    const editor = window.monacoInitializer.getActiveEditor();
                    if (editor) {
                        const previousFlag = window.monacoInitializer.suspendHistoryRecording;
                        window.monacoInitializer.suspendHistoryRecording = true;
                        try {
                            editor.setValue('');
                        } finally {
                            window.monacoInitializer.suspendHistoryRecording = previousFlag;
                        }
                        if (window.monacoInitializer.historyDebounce) {
                            clearTimeout(window.monacoInitializer.historyDebounce);
                            window.monacoInitializer.historyDebounce = null;
                        }
                    }
                }

                // Wait for getMappingById function to be available
                let attempts = 0;
                while ((typeof window.getMappingById !== 'function') && attempts < 50) {
                    console.log(`‚è≥ Waiting for getMappingById... attempt ${attempts + 1}`);
                    await new Promise(resolve => setTimeout(resolve, 100));
                    attempts++;
                }

                if (typeof window.getMappingById !== 'function') {
                    throw new Error('getMappingById function not available after 5 seconds');
                }

                console.log(`üì° Fetching mapping ${mappingId} from WireMock...`);
                console.log('üì° Using WireMock URL:', window.wiremockBaseUrl);

                const mapping = await window.getMappingById(mappingId);
                console.log('üì° API response received:', mapping);
                
                if (mapping) {
                    // Wait for Monaco editor to be ready
                    let editorAttempts = 0;
                    while ((!window.monacoInitializer || !window.monacoInitializer.isInitialized) && editorAttempts < 100) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        editorAttempts++;
                    }
                    
                    if (window.monacoInitializer && typeof window.monacoInitializer.loadMappingIntoEditor === 'function') {
                        window.monacoInitializer.loadMappingIntoEditor(mapping);
                        showNotification(`Mapping "${mapping.name || mappingId}" loaded successfully`, 'success');
                        
                        // Update page title
                        document.title = `JSON Editor - ${mapping.name || mappingId}`;
                    } else {
                        throw new Error('Monaco editor not ready');
                    }
                } else {
                    throw new Error(`Mapping with ID ${mappingId} not found`);
                }
            } catch (error) {
                console.error('‚ùå Error loading mapping:', error);
                console.error('‚ùå Error details:', {
                    message: error.message,
                    stack: error.stack,
                    mappingId: mappingId,
                    wiremockUrl: window.wiremockBaseUrl
                });
                showNotification(`Failed to load mapping: ${error.message}`, 'error');

                if (window.monacoInitializer && typeof window.monacoInitializer.finalizeEditorMappingLoad === 'function') {
                    window.monacoInitializer.finalizeEditorMappingLoad();
                }

                // Show error in editor as comment
                const errorContent = `{
  "_error": "Failed to load mapping with ID: ${mappingId}",
  "_message": "${error.message.replace(/"/g, '\\"')}",
  "_wiremock_url": "${window.wiremockBaseUrl || 'NOT_SET'}",
  "_auth_header": "${(JSON.parse(localStorage.getItem('wiremock-settings') || '{}')).authHeader || 'NOT_SET'}",
  "_timestamp": "${new Date().toISOString()}",
  "_debug_info": "Check browser console (F12) for detailed logs",
  "_possible_issues": [
    "Mapping ID not found on server",
    "Authentication failed",
    "CORS policy blocking request",
    "Network connectivity issues",
    "WireMock server not responding"
  ]
}`;
                console.log('üìù Setting error content in editor:', errorContent);

                if (window.monacoInitializer && window.monacoInitializer.isInitialized) {
                    const editor = window.monacoInitializer.getActiveEditor();
                    if (editor) {
                        editor.setValue(errorContent);
                    }
                } else {
                    console.error('‚ùå Monaco editor not ready to show error');
                    // Try to set content after a delay
                    setTimeout(() => {
                        if (window.monacoInitializer && window.monacoInitializer.getActiveEditor) {
                            const editor = window.monacoInitializer.getActiveEditor();
                            if (editor) {
                                editor.setValue(errorContent);
                            }
                        }
                    }, 1000);
                }
            }
        }
        
        // Initialize URL parameters - simplified and reliable approach
        console.log('üöÄ [DEBUG] Script block executing...');
        console.log('üöÄ Setting up URL initialization...');

        // Wait for all scripts to be fully loaded, then initialize
        const initializeWhenReady = () => {
            console.log('üöÄ Checking if all components are ready...');
            console.log('üöÄ window.getMappingById:', typeof window.getMappingById);
            console.log('üöÄ window.monacoInitializer:', !!window.monacoInitializer);
            console.log('üöÄ window.wiremockBaseUrl:', !!window.wiremockBaseUrl);

            // window.wiremockBaseUrl will be set by initializeFromURL, so we don't require it here
            if (window.getMappingById && window.monacoInitializer) {
                console.log('‚úÖ Core components ready, calling initializeFromURL');
                initializeFromURL();
                return true;
            }
            return false;
        };

        // Try immediately
        if (!initializeWhenReady()) {
            // If not ready, wait and try again
            let attempts = 0;
            const tryInit = () => {
                attempts++;
                console.log(`üöÄ Initialization attempt ${attempts}`);

                if (initializeWhenReady()) {
                    return; // Success
                }

                if (attempts < 100) { // Try for up to 10 seconds
                    setTimeout(tryInit, 100);
                } else {
                    console.error('‚ùå Failed to initialize URL parameters after 100 attempts');
                    // Show error in editor
                    if (window.monacoInitializer && window.monacoInitializer.getActiveEditor) {
                        const editor = window.monacoInitializer.getActiveEditor();
                        if (editor) {
                            editor.setValue(`{
  "_error": "Failed to initialize editor",
  "_message": "Components failed to load properly",
  "_getMappingById": ${typeof window.getMappingById},
  "_monacoInitializer": ${!!window.monacoInitializer},
  "_wiremockBaseUrl": "${window.wiremockBaseUrl || 'NOT_SET'}"
}`);
                        }
                    }
                }
            };
            setTimeout(tryInit, 100);
        }
    </script>
</body>
</html>
