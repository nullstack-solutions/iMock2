# Архитектура хранения маппингов в iMock2

## 1. Локальное хранилище (MappingsStore)

### Структура данных

MappingsStore - это единый источник истины (Single Source of Truth) для всех маппингов в приложении. Он использует оптимизированную архитектуру для обеспечения высокой производительности в условиях высокой задержки и многопользовательского взаимодействия.

#### Основные свойства:

- **items**: `Map` - основное хранилище маппингов, где ключ - ID маппинга, значение - объект маппинга
- **metadata**: объект с метаданными синхронизации:
  - `serverVersion`: ETag или версия с сервера
  - `lastFullSync`: временная метка последней полной синхронизации
  - `lastIncrementalSync`: временная метка последней инкрементной синхронизации
  - `isSyncing`: флаг указывающий на текущую синхронизацию с сервером
  - `syncError`: последняя ошибка синхронизации (если есть)
- **pending**: `Map` - ожидающие операции для оптимистичного UI
- **indexes**: объект с индексами для быстрого поиска:
  - `byMethod`: `Map` - индекс по HTTP-методу (GET, POST и т.д.)
  - `byUrl`: `Map` - индекс по URL-паттерну
  - `byPriority`: `Map` - индекс по приоритету
  - `byScenario`: `Map` - индекс по сценарию (scenario name)
- **stats**: статистика:
  - `totalMappings`: общее количество маппингов
  - `pendingOperations`: количество ожидающих операций
  - `lastSyncDuration`: продолжительность последней синхронизации

#### Запросы:

- **requests**: `Map` - хранилище запросов для обратной совместимости

### Методы

- **get(id)**: получить маппинг по ID, учитывая ожидающие операции
- **getAll()**: получить все маппингы (исключая удаленные), включая оптимистичные создания
- **setFromServer(mappings, metadata)**: установить маппинги с сервера (полная синхронизация)
- **applyChanges({ added, updated, deleted })**: применить инкрементные изменения с сервера
- **addPending(operation)**: добавить ожидающую операцию для оптимистичного обновления
- **confirmPending(id, serverMapping)**: подтвердить ожидающую операцию (сервер подтвердил)
- **rollbackPending(id, originalMapping)**: откатить ожидающую операцию (сервер отклонил)
- **filter(criteria)**: фильтрация маппингов по критериям (метод, URL, приоритет, сценарий)
- **clear()**: очистка всех данных
- **rebuildIndexes()**: пересоздание всех индексов

### Оптимистичные обновления

MappingsStore поддерживает оптимистичные обновления для обеспечения быстрого отклика UI:
- При создании, обновлении или удалении маппингов операция добавляется в `pending`
- При получении данных из маппингов показываются оптимистичные версии, если они существуют
- После подтверждения на сервере ожидающие операции подтверждаются или откатываются

## 2. Серверное хранилище (WireMock)

### Основные маппинги

- **/__admin/mappings**: основной эндпоинт для получения и управления маппингами

### Сервисный кеш (Service Cache)

- **/__admin/mappings/00000000-0000-0000-0000-00000000cace**: специальный маппинг для хранения кеша данных
- Используется для быстрой загрузки при старте приложения
- Содержит снапшот маппингов с временной меткой
- TTL (время жизни) - 1 час
- Периодически обновляется SyncEngine

## 3. Синхронизация (SyncEngine)

### incrementalSync (каждые 10 секунд)

Функция инкрементной синхронизации выполняется каждые 10 секунд с целями:
- Быстрое обновление данных от других пользователей
- Обнаружение изменений, добавлений и удалений маппингов
- Обнаружение конфликтов и их разрешение

Алгоритм работы:
1. Получает текущие маппинги с сервера
2. Сравнивает с локальным хранилищем для обнаружения изменений
3. Применяет изменения к локальному хранилищу
4. Обрабатывает конфликты между локальными и серверными изменениями
5. Обновляет UI, если есть изменения
6. Показывает уведомления о изменениях, внесённых другими пользователями

### fullSync (каждые 5 минут)

Функция полной синхронизации выполняется каждые 5 минут с целями:
- Полное обновление всех маппингов с сервера
- Контроль целостности данных
- Резервная синхронизация, если инкрементная не работала

Алгоритм работы:
1. Запрашивает все маппинги с сервера
2. Заменяет все данные в локальном хранилище
3. Обновляет индексы и метаданные
4. Обновляет UI
5. Обновляет индикатор источника данных

### rebuildServiceCache (каждые 30 секунд)

Функция перестроения сервисного кеша выполняется каждые 30 секунд с целями:
- Поддержание актуальности кеша
- Ускорение последующих загрузок приложения
- Снижение нагрузки на сервер при старте

Алгоритм работы:
1. Проверяет, есть ли ожидающие операции или оптимистичные обновления
2. Сравнивает хэш текущих данных с хэшем последнего кеша
3. Если данные изменились и нет ожидающих операций:
   - Создаёт снапшот текущих маппингов с временной меткой
   - Очищает внутренние поля оптимистичных обновлений
   - Сохраняет снапшот как специальный маппинг на сервере (PUT, с fallback на POST)
4. Сохраняет хэш для следующей проверки

## 4. Потоки данных

### При загрузке страницы

1. Вызывается `connectToWireMock()` для установки соединения
2. Проверяется статус подключения к WireMock
3. Запускается `SyncEngine.coldStart()`:
   - Пробует загрузить данные из Service Cache (быстрая загрузка)
   - Если кеш успешен, отображает UI на основе кешированных данных
   - Запускает фоновую полную синхронизацию для получения актуальных данных
4. Запускаются таймеры синхронизации:
   - Инкрементная синхронизация каждые 10 секунд
   - Полная синхронизация каждые 5 минут
   - Перестроение кеша каждые 30 секунд

### При CRUD операциях (create/update/delete)

1. Выполняется оптимистичное обновление:
   - Маппинг добавляется/обновляется/удаляется в локальном хранилище
   - Операция добавляется в `pending` хранилище
   - UI обновляется мгновенно
2. Отправляется запрос на сервер для выполнения операции
3. При успешном ответе от сервера:
   - Вызывается `confirmPending()` для подтверждения операции
   - В реальном маппинге обновляются данные (включая реальный ID для новых маппингов)
4. При неудачном ответе:
   - Вызывается `rollbackPending()` для отката операции
   - Восстанавливается исходное состояние маппинга

### При Refresh

1. Вызывается полная синхронизация с сервером
2. Все локальные данные заменяются данными с сервера
3. Обновляются индексы и метаданные
4. Обновляется UI

### При изменениях другими пользователями

1. Инкрементная синхронизация каждые 10 секунд проверяет изменения
2. При обнаружении изменений от других пользователей:
   - Применяются изменения к локальному хранилищу
   - Проверяются конфликты с локальными изменениями
   - Показываются уведомления о внесённых изменениях
3. Обновляется UI с новыми данными

## 5. Обнаружение расхождений

### Как сравниваются данные

Сравнение данных происходит через несколько механизмов:

1. **Инкрементная синхронизация**: 
   - Сравниваются хэши JSON-представлений маппингов
   - Определяются добавленные, изменённые и удалённые маппинги
   - Используется метод `_hasChanged(local, server)` для определения изменений

2. **Сравнение при загрузке кеша**:
   - При загрузке из кеша происходит сравнение с актуальными данными с сервера
   - Фильтруются сервисные маппинги для корректного сравнения
   - Применяются оптимистичные обновления к серверным данным перед сравнением

3. **Проверка конфликтов**:
   - Когда ожидающая локальная операция и обновление с сервера затрагивают один маппинг
   - Используется принцип "last-write-wins" (последняя запись выигрывает)
   - Сравниваются временные метки (`metadata.edited`, `metadata.updated`, `metadata.created`)

### Когда показывается предупреждение

Предупреждения показываются в следующих случаях:

1. **Обнаружение расхождений при загрузке из кеша**:
   - При старте приложения, если количество маппингов в кеше отличается от количества на сервере
   - Если есть маппинги, присутствующие в кеше, но отсутствующие на сервере
   - Если есть маппинги, присутствующие на сервере, но отсутствующие в кеше

2. **Конфликты синхронизации**:
   - Когда локальные изменения и изменения от других пользователей конфликтуют
   - Показывается предупреждение, если серверная версия новее локальной
   - Показывается предупреждение, если маппинг был удалён другим пользователем

3. **Изменения от других пользователей**:
   - При обнаружении изменений, внесённых другими пользователями
   - Показывается информационное уведомление о внесённых изменениях

4. **Ошибки синхронизации**:
   - При ошибках во время синхронизации с сервером
   - При таймаутах запросов к серверу